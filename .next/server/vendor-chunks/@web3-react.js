"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@web3-react";
exports.ids = ["vendor-chunks/@web3-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/@web3-react/coinbase-wallet/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@web3-react/coinbase-wallet/dist/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CoinbaseWallet = void 0;\nconst types_1 = __webpack_require__(/*! @web3-react/types */ \"(ssr)/./node_modules/@web3-react/types/dist/index.js\");\nfunction parseChainId(chainId) {\n    return typeof chainId === 'number' ? chainId : Number.parseInt(chainId, chainId.startsWith('0x') ? 16 : 10);\n}\nclass CoinbaseWallet extends types_1.Connector {\n    constructor({ actions, options, onError }) {\n        super(actions, onError);\n        this.options = options;\n    }\n    // the `connected` property, is bugged, but this works as a hack to check connection status\n    get connected() {\n        var _a;\n        return !!((_a = this.provider) === null || _a === void 0 ? void 0 : _a.selectedAddress);\n    }\n    isomorphicInitialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.eagerConnection)\n                return;\n            yield (this.eagerConnection = Promise.resolve().then(() => __importStar(__webpack_require__(/*! @coinbase/wallet-sdk */ \"(ssr)/./node_modules/@coinbase/wallet-sdk/dist/index.js\"))).then((m) => {\n                const _a = this.options, { url } = _a, options = __rest(_a, [\"url\"]);\n                this.coinbaseWallet = new m.default(options);\n                this.provider = this.coinbaseWallet.makeWeb3Provider(url);\n                this.provider.on('connect', ({ chainId }) => {\n                    this.actions.update({ chainId: parseChainId(chainId) });\n                });\n                this.provider.on('disconnect', (error) => {\n                    var _a;\n                    this.actions.resetState();\n                    (_a = this.onError) === null || _a === void 0 ? void 0 : _a.call(this, error);\n                });\n                this.provider.on('chainChanged', (chainId) => {\n                    this.actions.update({ chainId: parseChainId(chainId) });\n                });\n                this.provider.on('accountsChanged', (accounts) => {\n                    if (accounts.length === 0) {\n                        // handle this edge case by disconnecting\n                        this.actions.resetState();\n                    }\n                    else {\n                        this.actions.update({ accounts });\n                    }\n                });\n            }));\n        });\n    }\n    /** {@inheritdoc Connector.connectEagerly} */\n    connectEagerly() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cancelActivation = this.actions.startActivation();\n            try {\n                yield this.isomorphicInitialize();\n                if (!this.provider || !this.connected)\n                    throw new Error('No existing connection');\n                // Wallets may resolve eth_chainId and hang on eth_accounts pending user interaction, which may include changing\n                // chains; they should be requested serially, with accounts first, so that the chainId can settle.\n                const accounts = yield this.provider.request({ method: 'eth_accounts' });\n                if (!accounts.length)\n                    throw new Error('No accounts returned');\n                const chainId = yield this.provider.request({ method: 'eth_chainId' });\n                this.actions.update({ chainId: parseChainId(chainId), accounts });\n            }\n            catch (error) {\n                cancelActivation();\n                throw error;\n            }\n        });\n    }\n    /**\n     * Initiates a connection.\n     *\n     * @param desiredChainIdOrChainParameters - If defined, indicates the desired chain to connect to. If the user is\n     * already connected to this chain, no additional steps will be taken. Otherwise, the user will be prompted to switch\n     * to the chain, if one of two conditions is met: either they already have it added, or the argument is of type\n     * AddEthereumChainParameter, in which case the user will be prompted to add the chain with the specified parameters\n     * first, before being prompted to switch.\n     */\n    activate(desiredChainIdOrChainParameters) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const desiredChainId = typeof desiredChainIdOrChainParameters === 'number'\n                ? desiredChainIdOrChainParameters\n                : desiredChainIdOrChainParameters === null || desiredChainIdOrChainParameters === void 0 ? void 0 : desiredChainIdOrChainParameters.chainId;\n            if (this.provider && this.connected) {\n                if (!desiredChainId || desiredChainId === parseChainId(this.provider.chainId))\n                    return;\n                const desiredChainIdHex = `0x${desiredChainId.toString(16)}`;\n                return this.provider\n                    .request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: desiredChainIdHex }],\n                })\n                    .catch((error) => __awaiter(this, void 0, void 0, function* () {\n                    if (error.code === 4902 && typeof desiredChainIdOrChainParameters !== 'number') {\n                        if (!this.provider)\n                            throw new Error('No provider');\n                        // if we're here, we can try to add a new network\n                        return this.provider.request({\n                            method: 'wallet_addEthereumChain',\n                            params: [Object.assign(Object.assign({}, desiredChainIdOrChainParameters), { chainId: desiredChainIdHex })],\n                        });\n                    }\n                    throw error;\n                }));\n            }\n            const cancelActivation = this.actions.startActivation();\n            try {\n                yield this.isomorphicInitialize();\n                if (!this.provider)\n                    throw new Error('No provider');\n                // Wallets may resolve eth_chainId and hang on eth_accounts pending user interaction, which may include changing\n                // chains; they should be requested serially, with accounts first, so that the chainId can settle.\n                const accounts = yield this.provider.request({ method: 'eth_requestAccounts' });\n                const chainId = yield this.provider.request({ method: 'eth_chainId' });\n                const receivedChainId = parseChainId(chainId);\n                if (!desiredChainId || desiredChainId === receivedChainId)\n                    return this.actions.update({ chainId: receivedChainId, accounts });\n                // if we're here, we can try to switch networks\n                const desiredChainIdHex = `0x${desiredChainId.toString(16)}`;\n                return (_a = this.provider) === null || _a === void 0 ? void 0 : _a.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: desiredChainIdHex }],\n                }).catch((error) => __awaiter(this, void 0, void 0, function* () {\n                    if (error.code === 4902 && typeof desiredChainIdOrChainParameters !== 'number') {\n                        if (!this.provider)\n                            throw new Error('No provider');\n                        // if we're here, we can try to add a new network\n                        return this.provider.request({\n                            method: 'wallet_addEthereumChain',\n                            params: [Object.assign(Object.assign({}, desiredChainIdOrChainParameters), { chainId: desiredChainIdHex })],\n                        });\n                    }\n                    throw error;\n                }));\n            }\n            catch (error) {\n                cancelActivation();\n                throw error;\n            }\n        });\n    }\n    /** {@inheritdoc Connector.deactivate} */\n    deactivate() {\n        var _a;\n        (_a = this.coinbaseWallet) === null || _a === void 0 ? void 0 : _a.disconnect();\n    }\n    watchAsset({ address, symbol, decimals, image, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.provider)\n                throw new Error('No provider');\n            return this.provider\n                .request({\n                method: 'wallet_watchAsset',\n                params: {\n                    type: 'ERC20',\n                    options: {\n                        address,\n                        symbol,\n                        decimals,\n                        image, // A string url of the token logo\n                    },\n                },\n            })\n                .then((success) => {\n                if (!success)\n                    throw new Error('Rejected');\n                return true;\n            });\n        });\n    }\n}\nexports.CoinbaseWallet = CoinbaseWallet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3QvY29pbmJhc2Utd2FsbGV0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QixnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixtQkFBTyxDQUFDLHFGQUFzQjtBQUNsSCwyQ0FBMkMsTUFBTTtBQUNqRDtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQsMENBQTBDLGdDQUFnQztBQUMxRSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwwQ0FBMEMsZ0NBQWdDO0FBQzFFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsU0FBUyxzQ0FBc0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwrREFBK0Qsd0JBQXdCO0FBQ3ZGO0FBQ0E7QUFDQSw4REFBOEQsdUJBQXVCO0FBQ3JGLHNDQUFzQywwQ0FBMEM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QjtBQUMzRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsc0NBQXNDLDRCQUE0QjtBQUNySSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwrREFBK0QsK0JBQStCO0FBQzlGLDhEQUE4RCx1QkFBdUI7QUFDckY7QUFDQTtBQUNBLGlEQUFpRCxvQ0FBb0M7QUFDckY7QUFDQSwrQ0FBK0MsNEJBQTRCO0FBQzNFO0FBQ0E7QUFDQSwrQkFBK0IsNEJBQTRCO0FBQzNELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsc0NBQXNDLDRCQUE0QjtBQUNySSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUyxrQ0FBa0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUNBQW1DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93YWxsZXQtY29ubmVjdGlvbnMvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3QvY29pbmJhc2Utd2FsbGV0L2Rpc3QvaW5kZXguanM/ZjIwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvaW5iYXNlV2FsbGV0ID0gdm9pZCAwO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCJAd2ViMy1yZWFjdC90eXBlc1wiKTtcbmZ1bmN0aW9uIHBhcnNlQ2hhaW5JZChjaGFpbklkKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjaGFpbklkID09PSAnbnVtYmVyJyA/IGNoYWluSWQgOiBOdW1iZXIucGFyc2VJbnQoY2hhaW5JZCwgY2hhaW5JZC5zdGFydHNXaXRoKCcweCcpID8gMTYgOiAxMCk7XG59XG5jbGFzcyBDb2luYmFzZVdhbGxldCBleHRlbmRzIHR5cGVzXzEuQ29ubmVjdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGFjdGlvbnMsIG9wdGlvbnMsIG9uRXJyb3IgfSkge1xuICAgICAgICBzdXBlcihhY3Rpb25zLCBvbkVycm9yKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLy8gdGhlIGBjb25uZWN0ZWRgIHByb3BlcnR5LCBpcyBidWdnZWQsIGJ1dCB0aGlzIHdvcmtzIGFzIGEgaGFjayB0byBjaGVjayBjb25uZWN0aW9uIHN0YXR1c1xuICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICEhKChfYSA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZWxlY3RlZEFkZHJlc3MpO1xuICAgIH1cbiAgICBpc29tb3JwaGljSW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVhZ2VyQ29ubmVjdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB5aWVsZCAodGhpcy5lYWdlckNvbm5lY3Rpb24gPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IF9faW1wb3J0U3RhcihyZXF1aXJlKCdAY29pbmJhc2Uvd2FsbGV0LXNkaycpKSkudGhlbigobSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9hID0gdGhpcy5vcHRpb25zLCB7IHVybCB9ID0gX2EsIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtcInVybFwiXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2luYmFzZVdhbGxldCA9IG5ldyBtLmRlZmF1bHQob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlciA9IHRoaXMuY29pbmJhc2VXYWxsZXQubWFrZVdlYjNQcm92aWRlcih1cmwpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub24oJ2Nvbm5lY3QnLCAoeyBjaGFpbklkIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnVwZGF0ZSh7IGNoYWluSWQ6IHBhcnNlQ2hhaW5JZChjaGFpbklkKSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKCdkaXNjb25uZWN0JywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5vbkVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbignY2hhaW5DaGFuZ2VkJywgKGNoYWluSWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnVwZGF0ZSh7IGNoYWluSWQ6IHBhcnNlQ2hhaW5JZChjaGFpbklkKSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKCdhY2NvdW50c0NoYW5nZWQnLCAoYWNjb3VudHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRoaXMgZWRnZSBjYXNlIGJ5IGRpc2Nvbm5lY3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMudXBkYXRlKHsgYWNjb3VudHMgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiB7QGluaGVyaXRkb2MgQ29ubmVjdG9yLmNvbm5lY3RFYWdlcmx5fSAqL1xuICAgIGNvbm5lY3RFYWdlcmx5KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsQWN0aXZhdGlvbiA9IHRoaXMuYWN0aW9ucy5zdGFydEFjdGl2YXRpb24oKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5pc29tb3JwaGljSW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm92aWRlciB8fCAhdGhpcy5jb25uZWN0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXhpc3RpbmcgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgICAgIC8vIFdhbGxldHMgbWF5IHJlc29sdmUgZXRoX2NoYWluSWQgYW5kIGhhbmcgb24gZXRoX2FjY291bnRzIHBlbmRpbmcgdXNlciBpbnRlcmFjdGlvbiwgd2hpY2ggbWF5IGluY2x1ZGUgY2hhbmdpbmdcbiAgICAgICAgICAgICAgICAvLyBjaGFpbnM7IHRoZXkgc2hvdWxkIGJlIHJlcXVlc3RlZCBzZXJpYWxseSwgd2l0aCBhY2NvdW50cyBmaXJzdCwgc28gdGhhdCB0aGUgY2hhaW5JZCBjYW4gc2V0dGxlLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0geWllbGQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2FjY291bnRzJyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY291bnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2NvdW50cyByZXR1cm5lZCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfY2hhaW5JZCcgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnVwZGF0ZSh7IGNoYWluSWQ6IHBhcnNlQ2hhaW5JZChjaGFpbklkKSwgYWNjb3VudHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxBY3RpdmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZXMgYSBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRlc2lyZWRDaGFpbklkT3JDaGFpblBhcmFtZXRlcnMgLSBJZiBkZWZpbmVkLCBpbmRpY2F0ZXMgdGhlIGRlc2lyZWQgY2hhaW4gdG8gY29ubmVjdCB0by4gSWYgdGhlIHVzZXIgaXNcbiAgICAgKiBhbHJlYWR5IGNvbm5lY3RlZCB0byB0aGlzIGNoYWluLCBubyBhZGRpdGlvbmFsIHN0ZXBzIHdpbGwgYmUgdGFrZW4uIE90aGVyd2lzZSwgdGhlIHVzZXIgd2lsbCBiZSBwcm9tcHRlZCB0byBzd2l0Y2hcbiAgICAgKiB0byB0aGUgY2hhaW4sIGlmIG9uZSBvZiB0d28gY29uZGl0aW9ucyBpcyBtZXQ6IGVpdGhlciB0aGV5IGFscmVhZHkgaGF2ZSBpdCBhZGRlZCwgb3IgdGhlIGFyZ3VtZW50IGlzIG9mIHR5cGVcbiAgICAgKiBBZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyLCBpbiB3aGljaCBjYXNlIHRoZSB1c2VyIHdpbGwgYmUgcHJvbXB0ZWQgdG8gYWRkIHRoZSBjaGFpbiB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVyc1xuICAgICAqIGZpcnN0LCBiZWZvcmUgYmVpbmcgcHJvbXB0ZWQgdG8gc3dpdGNoLlxuICAgICAqL1xuICAgIGFjdGl2YXRlKGRlc2lyZWRDaGFpbklkT3JDaGFpblBhcmFtZXRlcnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGVzaXJlZENoYWluSWQgPSB0eXBlb2YgZGVzaXJlZENoYWluSWRPckNoYWluUGFyYW1ldGVycyA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICA/IGRlc2lyZWRDaGFpbklkT3JDaGFpblBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICA6IGRlc2lyZWRDaGFpbklkT3JDaGFpblBhcmFtZXRlcnMgPT09IG51bGwgfHwgZGVzaXJlZENoYWluSWRPckNoYWluUGFyYW1ldGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVzaXJlZENoYWluSWRPckNoYWluUGFyYW1ldGVycy5jaGFpbklkO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvdmlkZXIgJiYgdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlc2lyZWRDaGFpbklkIHx8IGRlc2lyZWRDaGFpbklkID09PSBwYXJzZUNoYWluSWQodGhpcy5wcm92aWRlci5jaGFpbklkKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRDaGFpbklkSGV4ID0gYDB4JHtkZXNpcmVkQ2hhaW5JZC50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlclxuICAgICAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbeyBjaGFpbklkOiBkZXNpcmVkQ2hhaW5JZEhleCB9XSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSA0OTAyICYmIHR5cGVvZiBkZXNpcmVkQ2hhaW5JZE9yQ2hhaW5QYXJhbWV0ZXJzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJvdmlkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGhlcmUsIHdlIGNhbiB0cnkgdG8gYWRkIGEgbmV3IG5ldHdvcmtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9hZGRFdGhlcmV1bUNoYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlc2lyZWRDaGFpbklkT3JDaGFpblBhcmFtZXRlcnMpLCB7IGNoYWluSWQ6IGRlc2lyZWRDaGFpbklkSGV4IH0pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbEFjdGl2YXRpb24gPSB0aGlzLmFjdGlvbnMuc3RhcnRBY3RpdmF0aW9uKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuaXNvbW9ycGhpY0luaXRpYWxpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJvdmlkZXInKTtcbiAgICAgICAgICAgICAgICAvLyBXYWxsZXRzIG1heSByZXNvbHZlIGV0aF9jaGFpbklkIGFuZCBoYW5nIG9uIGV0aF9hY2NvdW50cyBwZW5kaW5nIHVzZXIgaW50ZXJhY3Rpb24sIHdoaWNoIG1heSBpbmNsdWRlIGNoYW5naW5nXG4gICAgICAgICAgICAgICAgLy8gY2hhaW5zOyB0aGV5IHNob3VsZCBiZSByZXF1ZXN0ZWQgc2VyaWFsbHksIHdpdGggYWNjb3VudHMgZmlyc3QsIHNvIHRoYXQgdGhlIGNoYWluSWQgY2FuIHNldHRsZS5cbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IHlpZWxkIHRoaXMucHJvdmlkZXIucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9yZXF1ZXN0QWNjb3VudHMnIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfY2hhaW5JZCcgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjZWl2ZWRDaGFpbklkID0gcGFyc2VDaGFpbklkKGNoYWluSWQpO1xuICAgICAgICAgICAgICAgIGlmICghZGVzaXJlZENoYWluSWQgfHwgZGVzaXJlZENoYWluSWQgPT09IHJlY2VpdmVkQ2hhaW5JZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucy51cGRhdGUoeyBjaGFpbklkOiByZWNlaXZlZENoYWluSWQsIGFjY291bnRzIH0pO1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGhlcmUsIHdlIGNhbiB0cnkgdG8gc3dpdGNoIG5ldHdvcmtzXG4gICAgICAgICAgICAgICAgY29uc3QgZGVzaXJlZENoYWluSWRIZXggPSBgMHgke2Rlc2lyZWRDaGFpbklkLnRvU3RyaW5nKDE2KX1gO1xuICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbeyBjaGFpbklkOiBkZXNpcmVkQ2hhaW5JZEhleCB9XSxcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IDQ5MDIgJiYgdHlwZW9mIGRlc2lyZWRDaGFpbklkT3JDaGFpblBhcmFtZXRlcnMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwcm92aWRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgaGVyZSwgd2UgY2FuIHRyeSB0byBhZGQgYSBuZXcgbmV0d29ya1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW09iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVzaXJlZENoYWluSWRPckNoYWluUGFyYW1ldGVycyksIHsgY2hhaW5JZDogZGVzaXJlZENoYWluSWRIZXggfSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsQWN0aXZhdGlvbigpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIHtAaW5oZXJpdGRvYyBDb25uZWN0b3IuZGVhY3RpdmF0ZX0gKi9cbiAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY29pbmJhc2VXYWxsZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIHdhdGNoQXNzZXQoeyBhZGRyZXNzLCBzeW1ib2wsIGRlY2ltYWxzLCBpbWFnZSwgfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJvdmlkZXInKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyXG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF93YXRjaEFzc2V0JyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0VSQzIwJyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UsIC8vIEEgc3RyaW5nIHVybCBvZiB0aGUgdG9rZW4gbG9nb1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChzdWNjZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlamVjdGVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db2luYmFzZVdhbGxldCA9IENvaW5iYXNlV2FsbGV0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-react/coinbase-wallet/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@web3-react/core/dist/hooks.js":
/*!*****************************************************!*\
  !*** ./node_modules/@web3-react/core/dist/hooks.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getPriorityConnector = exports.getSelectedConnector = exports.initializeConnector = void 0;\nconst store_1 = __webpack_require__(/*! @web3-react/store */ \"(ssr)/./node_modules/@web3-react/store/dist/index.js\");\nconst react_1 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nconst zustand_1 = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/zustand/esm/index.js\");\nconst traditional_1 = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/zustand/esm/traditional.js\");\nlet DynamicProvider;\nfunction importProvider() {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (DynamicProvider === undefined) {\n            try {\n                const { Web3Provider } = yield Promise.resolve().then(() => __importStar(__webpack_require__(/*! @ethersproject/providers */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/index.js\")));\n                DynamicProvider = Web3Provider;\n            }\n            catch (_a) {\n                console.debug('@ethersproject/providers not available');\n                DynamicProvider = null;\n            }\n        }\n    });\n}\n/**\n * Wraps the initialization of a `connector`. Creates a zustand `store` with `actions` bound to it, and then passes\n * these to the connector as specified in `f`. Also creates a variety of `hooks` bound to this `store`.\n *\n * @typeParam T - The type of the `connector` returned from `f`.\n * @param f - A function which is called with `actions` bound to the returned `store`.\n * @returns [connector, hooks, store] - The initialized connector, a variety of hooks, and a zustand store.\n */\nfunction initializeConnector(f) {\n    const [store, actions] = (0, store_1.createWeb3ReactStoreAndActions)();\n    const connector = f(actions);\n    const stateHooks = getStateHooks(store);\n    const derivedHooks = getDerivedHooks(stateHooks);\n    const augmentedHooks = getAugmentedHooks(connector, stateHooks, derivedHooks);\n    return [connector, Object.assign(Object.assign(Object.assign({}, stateHooks), derivedHooks), augmentedHooks), store];\n}\nexports.initializeConnector = initializeConnector;\nfunction computeIsActive({ chainId, accounts, activating }) {\n    return Boolean(chainId && accounts && !activating);\n}\n/**\n * Creates a variety of convenience `hooks` that return data associated with a particular passed connector.\n *\n * @param initializedConnectors - Two or more [connector, hooks(, store)] arrays, as returned from initializeConnector.\n * @returns hooks - A variety of convenience hooks that wrap the hooks returned from initializeConnector.\n */\nfunction getSelectedConnector(...initializedConnectors) {\n    function getIndex(connector) {\n        const index = initializedConnectors.findIndex(([initializedConnector]) => connector === initializedConnector);\n        if (index === -1)\n            throw new Error('Connector not found');\n        return index;\n    }\n    function useSelectedStore(connector) {\n        const store = initializedConnectors[getIndex(connector)][2];\n        if (!store)\n            throw new Error('Stores not passed');\n        return store;\n    }\n    // the following code calls hooks in a map a lot, which violates the eslint rule.\n    // this is ok, though, because initializedConnectors never changes, so the same hooks are called each time\n    function useSelectedChainId(connector) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const values = initializedConnectors.map(([, { useChainId }]) => useChainId());\n        return values[getIndex(connector)];\n    }\n    function useSelectedAccounts(connector) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const values = initializedConnectors.map(([, { useAccounts }]) => useAccounts());\n        return values[getIndex(connector)];\n    }\n    function useSelectedIsActivating(connector) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const values = initializedConnectors.map(([, { useIsActivating }]) => useIsActivating());\n        return values[getIndex(connector)];\n    }\n    function useSelectedAccount(connector) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const values = initializedConnectors.map(([, { useAccount }]) => useAccount());\n        return values[getIndex(connector)];\n    }\n    function useSelectedIsActive(connector) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const values = initializedConnectors.map(([, { useIsActive }]) => useIsActive());\n        return values[getIndex(connector)];\n    }\n    /**\n     * @typeParam T - A type argument must only be provided if one or more of the connectors passed to\n     * getSelectedConnector is using `connector.customProvider`, in which case it must match every possible type of this\n     * property, over all connectors.\n     */\n    function useSelectedProvider(connector, network) {\n        const index = getIndex(connector);\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const values = initializedConnectors.map(([, { useProvider }], i) => useProvider(network, i === index));\n        return values[index];\n    }\n    function useSelectedENSNames(connector, provider) {\n        const index = getIndex(connector);\n        const values = initializedConnectors.map(([, { useENSNames }], i) => \n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        useENSNames(i === index ? provider : undefined));\n        return values[index];\n    }\n    function useSelectedENSName(connector, provider) {\n        const index = getIndex(connector);\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const values = initializedConnectors.map(([, { useENSName }], i) => useENSName(i === index ? provider : undefined));\n        return values[index];\n    }\n    return {\n        useSelectedStore,\n        useSelectedChainId,\n        useSelectedAccounts,\n        useSelectedIsActivating,\n        useSelectedAccount,\n        useSelectedIsActive,\n        useSelectedProvider,\n        useSelectedENSNames,\n        useSelectedENSName,\n    };\n}\nexports.getSelectedConnector = getSelectedConnector;\n/**\n * Creates a variety of convenience `hooks` that return data associated with the first of the `initializedConnectors`\n * that is active.\n *\n * @param initializedConnectors - Two or more [connector, hooks(, store)] arrays, as returned from initializeConnector.\n * @returns hooks - A variety of convenience hooks that wrap the hooks returned from initializeConnector.\n */\nfunction getPriorityConnector(...initializedConnectors) {\n    const { useSelectedStore, useSelectedChainId, useSelectedAccounts, useSelectedIsActivating, useSelectedAccount, useSelectedIsActive, useSelectedProvider, useSelectedENSNames, useSelectedENSName, } = getSelectedConnector(...initializedConnectors);\n    function usePriorityConnector() {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const values = initializedConnectors.map(([, { useIsActive }]) => useIsActive());\n        const index = values.findIndex((isActive) => isActive);\n        return initializedConnectors[index === -1 ? 0 : index][0];\n    }\n    function usePriorityStore() {\n        return useSelectedStore(usePriorityConnector());\n    }\n    function usePriorityChainId() {\n        return useSelectedChainId(usePriorityConnector());\n    }\n    function usePriorityAccounts() {\n        return useSelectedAccounts(usePriorityConnector());\n    }\n    function usePriorityIsActivating() {\n        return useSelectedIsActivating(usePriorityConnector());\n    }\n    function usePriorityAccount() {\n        return useSelectedAccount(usePriorityConnector());\n    }\n    function usePriorityIsActive() {\n        return useSelectedIsActive(usePriorityConnector());\n    }\n    /**\n     * @typeParam T - A type argument must only be provided if one or more of the connectors passed to\n     * getPriorityConnector is using `connector.customProvider`, in which case it must match every possible type of this\n     * property, over all connectors.\n     */\n    function usePriorityProvider(network) {\n        return useSelectedProvider(usePriorityConnector(), network);\n    }\n    function usePriorityENSNames(provider) {\n        return useSelectedENSNames(usePriorityConnector(), provider);\n    }\n    function usePriorityENSName(provider) {\n        return useSelectedENSName(usePriorityConnector(), provider);\n    }\n    return {\n        useSelectedStore,\n        useSelectedChainId,\n        useSelectedAccounts,\n        useSelectedIsActivating,\n        useSelectedAccount,\n        useSelectedIsActive,\n        useSelectedProvider,\n        useSelectedENSNames,\n        useSelectedENSName,\n        usePriorityConnector,\n        usePriorityStore,\n        usePriorityChainId,\n        usePriorityAccounts,\n        usePriorityIsActivating,\n        usePriorityAccount,\n        usePriorityIsActive,\n        usePriorityProvider,\n        usePriorityENSNames,\n        usePriorityENSName,\n    };\n}\nexports.getPriorityConnector = getPriorityConnector;\nconst CHAIN_ID = ({ chainId }) => chainId;\nconst ACCOUNTS = ({ accounts }) => accounts;\nconst ACTIVATING = ({ activating }) => activating;\nconst ACCOUNTS_EQUALITY_CHECKER = (oldAccounts, newAccounts) => (oldAccounts === undefined && newAccounts === undefined) ||\n    (oldAccounts !== undefined &&\n        oldAccounts.length === (newAccounts === null || newAccounts === void 0 ? void 0 : newAccounts.length) &&\n        oldAccounts.every((oldAccount, i) => oldAccount === newAccounts[i]));\nfunction getStateHooks(store) {\n    function useChainId() {\n        return (0, zustand_1.useStore)(store, CHAIN_ID);\n    }\n    function useAccounts() {\n        return (0, traditional_1.useStoreWithEqualityFn)(store, ACCOUNTS, ACCOUNTS_EQUALITY_CHECKER);\n    }\n    function useIsActivating() {\n        return (0, zustand_1.useStore)(store, ACTIVATING);\n    }\n    return { useChainId, useAccounts, useIsActivating };\n}\nfunction getDerivedHooks({ useChainId, useAccounts, useIsActivating }) {\n    function useAccount() {\n        var _a;\n        return (_a = useAccounts()) === null || _a === void 0 ? void 0 : _a[0];\n    }\n    function useIsActive() {\n        const chainId = useChainId();\n        const accounts = useAccounts();\n        const activating = useIsActivating();\n        return computeIsActive({\n            chainId,\n            accounts,\n            activating,\n        });\n    }\n    return { useAccount, useIsActive };\n}\n/**\n * @returns ENSNames - An array of length `accounts.length` which contains entries which are either all `undefined`,\n * indicated that names cannot be fetched because there's no provider, or they're in the process of being fetched,\n * or `string | null`, depending on whether an ENS name has been set for the account in question or not.\n */\nfunction useENS(provider, accounts = []) {\n    const [ENSNames, setENSNames] = (0, react_1.useState)();\n    (0, react_1.useEffect)(() => {\n        if (provider && accounts.length) {\n            let stale = false;\n            Promise.all(accounts.map((account) => provider.lookupAddress(account)))\n                .then((ENSNames) => {\n                if (stale)\n                    return;\n                setENSNames(ENSNames);\n            })\n                .catch((error) => {\n                if (stale)\n                    return;\n                console.debug('Could not fetch ENS names', error);\n                setENSNames(new Array(accounts.length).fill(null));\n            });\n            return () => {\n                stale = true;\n                setENSNames(undefined);\n            };\n        }\n    }, [provider, accounts]);\n    return ENSNames !== null && ENSNames !== void 0 ? ENSNames : new Array(accounts.length).fill(undefined);\n}\nfunction getAugmentedHooks(connector, { useAccounts, useChainId }, { useAccount, useIsActive }) {\n    /**\n     * Avoid type erasure by returning the most qualified type if not otherwise set.\n     * Note that this function's return type is `T | undefined`, but there is a code path\n     * that returns a Web3Provider, which could conflict with a user-provided T. So,\n     * it's important that users only provide an override for T if they know that\n     * `connector.customProvider` is going to be defined and of type T.\n     *\n     * @typeParam T - A type argument must only be provided if using `connector.customProvider`, in which case it\n     * must match the type of this property.\n     */\n    function useProvider(network, enabled = true) {\n        const isActive = useIsActive();\n        const chainId = useChainId();\n        // ensure that Provider is going to be available when loaded if @ethersproject/providers is installed\n        const [loaded, setLoaded] = (0, react_1.useState)(DynamicProvider !== undefined);\n        (0, react_1.useEffect)(() => {\n            if (loaded)\n                return;\n            let stale = false;\n            void importProvider().then(() => {\n                if (stale)\n                    return;\n                setLoaded(true);\n            });\n            return () => {\n                stale = true;\n            };\n        }, [loaded]);\n        return (0, react_1.useMemo)(() => {\n            // to ensure connectors remain fresh, we condition re-renders on loaded, isActive and chainId\n            void loaded && isActive && chainId;\n            if (enabled) {\n                if (connector.customProvider)\n                    return connector.customProvider;\n                // see tsdoc note above for return type explanation.\n                else if (DynamicProvider && connector.provider)\n                    return new DynamicProvider(connector.provider, network);\n            }\n        }, [loaded, enabled, isActive, chainId, network]);\n    }\n    function useENSNames(provider) {\n        const accounts = useAccounts();\n        return useENS(provider, accounts);\n    }\n    function useENSName(provider) {\n        var _a;\n        const account = useAccount();\n        const accounts = (0, react_1.useMemo)(() => (account === undefined ? undefined : [account]), [account]);\n        return (_a = useENS(provider, accounts)) === null || _a === void 0 ? void 0 : _a[0];\n    }\n    return { useProvider, useENSNames, useENSName };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3QvY29yZS9kaXN0L2hvb2tzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsNEJBQTRCLEdBQUcsMkJBQTJCO0FBQ3pGLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFtQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBTztBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQywwREFBUztBQUNuQyxzQkFBc0IsbUJBQU8sQ0FBQyw0RUFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlLGtEQUFrRCxtQkFBTyxDQUFDLGdHQUEwQjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSwyQkFBMkI7QUFDM0IsMkJBQTJCLCtCQUErQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxZQUFZO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsaUJBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsYUFBYTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZMQUE2TDtBQUN6TTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLG9CQUFvQixTQUFTO0FBQzdCLG9CQUFvQixVQUFVO0FBQzlCLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyQkFBMkIsMENBQTBDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3Qyx5QkFBeUIsSUFBSSx5QkFBeUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL3dhbGxldC1jb25uZWN0aW9ucy8uL25vZGVfbW9kdWxlcy9Ad2ViMy1yZWFjdC9jb3JlL2Rpc3QvaG9va3MuanM/MjI2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFByaW9yaXR5Q29ubmVjdG9yID0gZXhwb3J0cy5nZXRTZWxlY3RlZENvbm5lY3RvciA9IGV4cG9ydHMuaW5pdGlhbGl6ZUNvbm5lY3RvciA9IHZvaWQgMDtcbmNvbnN0IHN0b3JlXzEgPSByZXF1aXJlKFwiQHdlYjMtcmVhY3Qvc3RvcmVcIik7XG5jb25zdCByZWFjdF8xID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgenVzdGFuZF8xID0gcmVxdWlyZShcInp1c3RhbmRcIik7XG5jb25zdCB0cmFkaXRpb25hbF8xID0gcmVxdWlyZShcInp1c3RhbmQvdHJhZGl0aW9uYWxcIik7XG5sZXQgRHluYW1pY1Byb3ZpZGVyO1xuZnVuY3Rpb24gaW1wb3J0UHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKER5bmFtaWNQcm92aWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgV2ViM1Byb3ZpZGVyIH0gPSB5aWVsZCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IF9faW1wb3J0U3RhcihyZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9wcm92aWRlcnMnKSkpO1xuICAgICAgICAgICAgICAgIER5bmFtaWNQcm92aWRlciA9IFdlYjNQcm92aWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycyBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICAgICAgRHluYW1pY1Byb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBXcmFwcyB0aGUgaW5pdGlhbGl6YXRpb24gb2YgYSBgY29ubmVjdG9yYC4gQ3JlYXRlcyBhIHp1c3RhbmQgYHN0b3JlYCB3aXRoIGBhY3Rpb25zYCBib3VuZCB0byBpdCwgYW5kIHRoZW4gcGFzc2VzXG4gKiB0aGVzZSB0byB0aGUgY29ubmVjdG9yIGFzIHNwZWNpZmllZCBpbiBgZmAuIEFsc28gY3JlYXRlcyBhIHZhcmlldHkgb2YgYGhvb2tzYCBib3VuZCB0byB0aGlzIGBzdG9yZWAuXG4gKlxuICogQHR5cGVQYXJhbSBUIC0gVGhlIHR5cGUgb2YgdGhlIGBjb25uZWN0b3JgIHJldHVybmVkIGZyb20gYGZgLlxuICogQHBhcmFtIGYgLSBBIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCB3aXRoIGBhY3Rpb25zYCBib3VuZCB0byB0aGUgcmV0dXJuZWQgYHN0b3JlYC5cbiAqIEByZXR1cm5zIFtjb25uZWN0b3IsIGhvb2tzLCBzdG9yZV0gLSBUaGUgaW5pdGlhbGl6ZWQgY29ubmVjdG9yLCBhIHZhcmlldHkgb2YgaG9va3MsIGFuZCBhIHp1c3RhbmQgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVDb25uZWN0b3IoZikge1xuICAgIGNvbnN0IFtzdG9yZSwgYWN0aW9uc10gPSAoMCwgc3RvcmVfMS5jcmVhdGVXZWIzUmVhY3RTdG9yZUFuZEFjdGlvbnMpKCk7XG4gICAgY29uc3QgY29ubmVjdG9yID0gZihhY3Rpb25zKTtcbiAgICBjb25zdCBzdGF0ZUhvb2tzID0gZ2V0U3RhdGVIb29rcyhzdG9yZSk7XG4gICAgY29uc3QgZGVyaXZlZEhvb2tzID0gZ2V0RGVyaXZlZEhvb2tzKHN0YXRlSG9va3MpO1xuICAgIGNvbnN0IGF1Z21lbnRlZEhvb2tzID0gZ2V0QXVnbWVudGVkSG9va3MoY29ubmVjdG9yLCBzdGF0ZUhvb2tzLCBkZXJpdmVkSG9va3MpO1xuICAgIHJldHVybiBbY29ubmVjdG9yLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGVIb29rcyksIGRlcml2ZWRIb29rcyksIGF1Z21lbnRlZEhvb2tzKSwgc3RvcmVdO1xufVxuZXhwb3J0cy5pbml0aWFsaXplQ29ubmVjdG9yID0gaW5pdGlhbGl6ZUNvbm5lY3RvcjtcbmZ1bmN0aW9uIGNvbXB1dGVJc0FjdGl2ZSh7IGNoYWluSWQsIGFjY291bnRzLCBhY3RpdmF0aW5nIH0pIHtcbiAgICByZXR1cm4gQm9vbGVhbihjaGFpbklkICYmIGFjY291bnRzICYmICFhY3RpdmF0aW5nKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHZhcmlldHkgb2YgY29udmVuaWVuY2UgYGhvb2tzYCB0aGF0IHJldHVybiBkYXRhIGFzc29jaWF0ZWQgd2l0aCBhIHBhcnRpY3VsYXIgcGFzc2VkIGNvbm5lY3Rvci5cbiAqXG4gKiBAcGFyYW0gaW5pdGlhbGl6ZWRDb25uZWN0b3JzIC0gVHdvIG9yIG1vcmUgW2Nvbm5lY3RvciwgaG9va3MoLCBzdG9yZSldIGFycmF5cywgYXMgcmV0dXJuZWQgZnJvbSBpbml0aWFsaXplQ29ubmVjdG9yLlxuICogQHJldHVybnMgaG9va3MgLSBBIHZhcmlldHkgb2YgY29udmVuaWVuY2UgaG9va3MgdGhhdCB3cmFwIHRoZSBob29rcyByZXR1cm5lZCBmcm9tIGluaXRpYWxpemVDb25uZWN0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGVkQ29ubmVjdG9yKC4uLmluaXRpYWxpemVkQ29ubmVjdG9ycykge1xuICAgIGZ1bmN0aW9uIGdldEluZGV4KGNvbm5lY3Rvcikge1xuICAgICAgICBjb25zdCBpbmRleCA9IGluaXRpYWxpemVkQ29ubmVjdG9ycy5maW5kSW5kZXgoKFtpbml0aWFsaXplZENvbm5lY3Rvcl0pID0+IGNvbm5lY3RvciA9PT0gaW5pdGlhbGl6ZWRDb25uZWN0b3IpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0b3Igbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlU2VsZWN0ZWRTdG9yZShjb25uZWN0b3IpIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBpbml0aWFsaXplZENvbm5lY3RvcnNbZ2V0SW5kZXgoY29ubmVjdG9yKV1bMl07XG4gICAgICAgIGlmICghc3RvcmUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0b3JlcyBub3QgcGFzc2VkJyk7XG4gICAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9XG4gICAgLy8gdGhlIGZvbGxvd2luZyBjb2RlIGNhbGxzIGhvb2tzIGluIGEgbWFwIGEgbG90LCB3aGljaCB2aW9sYXRlcyB0aGUgZXNsaW50IHJ1bGUuXG4gICAgLy8gdGhpcyBpcyBvaywgdGhvdWdoLCBiZWNhdXNlIGluaXRpYWxpemVkQ29ubmVjdG9ycyBuZXZlciBjaGFuZ2VzLCBzbyB0aGUgc2FtZSBob29rcyBhcmUgY2FsbGVkIGVhY2ggdGltZVxuICAgIGZ1bmN0aW9uIHVzZVNlbGVjdGVkQ2hhaW5JZChjb25uZWN0b3IpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGluaXRpYWxpemVkQ29ubmVjdG9ycy5tYXAoKFssIHsgdXNlQ2hhaW5JZCB9XSkgPT4gdXNlQ2hhaW5JZCgpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1tnZXRJbmRleChjb25uZWN0b3IpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlU2VsZWN0ZWRBY2NvdW50cyhjb25uZWN0b3IpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGluaXRpYWxpemVkQ29ubmVjdG9ycy5tYXAoKFssIHsgdXNlQWNjb3VudHMgfV0pID0+IHVzZUFjY291bnRzKCkpO1xuICAgICAgICByZXR1cm4gdmFsdWVzW2dldEluZGV4KGNvbm5lY3RvcildO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VTZWxlY3RlZElzQWN0aXZhdGluZyhjb25uZWN0b3IpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGluaXRpYWxpemVkQ29ubmVjdG9ycy5tYXAoKFssIHsgdXNlSXNBY3RpdmF0aW5nIH1dKSA9PiB1c2VJc0FjdGl2YXRpbmcoKSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXNbZ2V0SW5kZXgoY29ubmVjdG9yKV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVNlbGVjdGVkQWNjb3VudChjb25uZWN0b3IpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGluaXRpYWxpemVkQ29ubmVjdG9ycy5tYXAoKFssIHsgdXNlQWNjb3VudCB9XSkgPT4gdXNlQWNjb3VudCgpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1tnZXRJbmRleChjb25uZWN0b3IpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlU2VsZWN0ZWRJc0FjdGl2ZShjb25uZWN0b3IpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGluaXRpYWxpemVkQ29ubmVjdG9ycy5tYXAoKFssIHsgdXNlSXNBY3RpdmUgfV0pID0+IHVzZUlzQWN0aXZlKCkpO1xuICAgICAgICByZXR1cm4gdmFsdWVzW2dldEluZGV4KGNvbm5lY3RvcildO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdHlwZVBhcmFtIFQgLSBBIHR5cGUgYXJndW1lbnQgbXVzdCBvbmx5IGJlIHByb3ZpZGVkIGlmIG9uZSBvciBtb3JlIG9mIHRoZSBjb25uZWN0b3JzIHBhc3NlZCB0b1xuICAgICAqIGdldFNlbGVjdGVkQ29ubmVjdG9yIGlzIHVzaW5nIGBjb25uZWN0b3IuY3VzdG9tUHJvdmlkZXJgLCBpbiB3aGljaCBjYXNlIGl0IG11c3QgbWF0Y2ggZXZlcnkgcG9zc2libGUgdHlwZSBvZiB0aGlzXG4gICAgICogcHJvcGVydHksIG92ZXIgYWxsIGNvbm5lY3RvcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXNlU2VsZWN0ZWRQcm92aWRlcihjb25uZWN0b3IsIG5ldHdvcmspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleChjb25uZWN0b3IpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgY29uc3QgdmFsdWVzID0gaW5pdGlhbGl6ZWRDb25uZWN0b3JzLm1hcCgoWywgeyB1c2VQcm92aWRlciB9XSwgaSkgPT4gdXNlUHJvdmlkZXIobmV0d29yaywgaSA9PT0gaW5kZXgpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1tpbmRleF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVNlbGVjdGVkRU5TTmFtZXMoY29ubmVjdG9yLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4KGNvbm5lY3Rvcik7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGluaXRpYWxpemVkQ29ubmVjdG9ycy5tYXAoKFssIHsgdXNlRU5TTmFtZXMgfV0sIGkpID0+IFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgdXNlRU5TTmFtZXMoaSA9PT0gaW5kZXggPyBwcm92aWRlciA6IHVuZGVmaW5lZCkpO1xuICAgICAgICByZXR1cm4gdmFsdWVzW2luZGV4XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlU2VsZWN0ZWRFTlNOYW1lKGNvbm5lY3RvciwgcHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleChjb25uZWN0b3IpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgY29uc3QgdmFsdWVzID0gaW5pdGlhbGl6ZWRDb25uZWN0b3JzLm1hcCgoWywgeyB1c2VFTlNOYW1lIH1dLCBpKSA9PiB1c2VFTlNOYW1lKGkgPT09IGluZGV4ID8gcHJvdmlkZXIgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1tpbmRleF07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVNlbGVjdGVkU3RvcmUsXG4gICAgICAgIHVzZVNlbGVjdGVkQ2hhaW5JZCxcbiAgICAgICAgdXNlU2VsZWN0ZWRBY2NvdW50cyxcbiAgICAgICAgdXNlU2VsZWN0ZWRJc0FjdGl2YXRpbmcsXG4gICAgICAgIHVzZVNlbGVjdGVkQWNjb3VudCxcbiAgICAgICAgdXNlU2VsZWN0ZWRJc0FjdGl2ZSxcbiAgICAgICAgdXNlU2VsZWN0ZWRQcm92aWRlcixcbiAgICAgICAgdXNlU2VsZWN0ZWRFTlNOYW1lcyxcbiAgICAgICAgdXNlU2VsZWN0ZWRFTlNOYW1lLFxuICAgIH07XG59XG5leHBvcnRzLmdldFNlbGVjdGVkQ29ubmVjdG9yID0gZ2V0U2VsZWN0ZWRDb25uZWN0b3I7XG4vKipcbiAqIENyZWF0ZXMgYSB2YXJpZXR5IG9mIGNvbnZlbmllbmNlIGBob29rc2AgdGhhdCByZXR1cm4gZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGZpcnN0IG9mIHRoZSBgaW5pdGlhbGl6ZWRDb25uZWN0b3JzYFxuICogdGhhdCBpcyBhY3RpdmUuXG4gKlxuICogQHBhcmFtIGluaXRpYWxpemVkQ29ubmVjdG9ycyAtIFR3byBvciBtb3JlIFtjb25uZWN0b3IsIGhvb2tzKCwgc3RvcmUpXSBhcnJheXMsIGFzIHJldHVybmVkIGZyb20gaW5pdGlhbGl6ZUNvbm5lY3Rvci5cbiAqIEByZXR1cm5zIGhvb2tzIC0gQSB2YXJpZXR5IG9mIGNvbnZlbmllbmNlIGhvb2tzIHRoYXQgd3JhcCB0aGUgaG9va3MgcmV0dXJuZWQgZnJvbSBpbml0aWFsaXplQ29ubmVjdG9yLlxuICovXG5mdW5jdGlvbiBnZXRQcmlvcml0eUNvbm5lY3RvciguLi5pbml0aWFsaXplZENvbm5lY3RvcnMpIHtcbiAgICBjb25zdCB7IHVzZVNlbGVjdGVkU3RvcmUsIHVzZVNlbGVjdGVkQ2hhaW5JZCwgdXNlU2VsZWN0ZWRBY2NvdW50cywgdXNlU2VsZWN0ZWRJc0FjdGl2YXRpbmcsIHVzZVNlbGVjdGVkQWNjb3VudCwgdXNlU2VsZWN0ZWRJc0FjdGl2ZSwgdXNlU2VsZWN0ZWRQcm92aWRlciwgdXNlU2VsZWN0ZWRFTlNOYW1lcywgdXNlU2VsZWN0ZWRFTlNOYW1lLCB9ID0gZ2V0U2VsZWN0ZWRDb25uZWN0b3IoLi4uaW5pdGlhbGl6ZWRDb25uZWN0b3JzKTtcbiAgICBmdW5jdGlvbiB1c2VQcmlvcml0eUNvbm5lY3RvcigpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGluaXRpYWxpemVkQ29ubmVjdG9ycy5tYXAoKFssIHsgdXNlSXNBY3RpdmUgfV0pID0+IHVzZUlzQWN0aXZlKCkpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHZhbHVlcy5maW5kSW5kZXgoKGlzQWN0aXZlKSA9PiBpc0FjdGl2ZSk7XG4gICAgICAgIHJldHVybiBpbml0aWFsaXplZENvbm5lY3RvcnNbaW5kZXggPT09IC0xID8gMCA6IGluZGV4XVswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlUHJpb3JpdHlTdG9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHVzZVNlbGVjdGVkU3RvcmUodXNlUHJpb3JpdHlDb25uZWN0b3IoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVByaW9yaXR5Q2hhaW5JZCgpIHtcbiAgICAgICAgcmV0dXJuIHVzZVNlbGVjdGVkQ2hhaW5JZCh1c2VQcmlvcml0eUNvbm5lY3RvcigpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlUHJpb3JpdHlBY2NvdW50cygpIHtcbiAgICAgICAgcmV0dXJuIHVzZVNlbGVjdGVkQWNjb3VudHModXNlUHJpb3JpdHlDb25uZWN0b3IoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVByaW9yaXR5SXNBY3RpdmF0aW5nKCkge1xuICAgICAgICByZXR1cm4gdXNlU2VsZWN0ZWRJc0FjdGl2YXRpbmcodXNlUHJpb3JpdHlDb25uZWN0b3IoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVByaW9yaXR5QWNjb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHVzZVNlbGVjdGVkQWNjb3VudCh1c2VQcmlvcml0eUNvbm5lY3RvcigpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlUHJpb3JpdHlJc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHVzZVNlbGVjdGVkSXNBY3RpdmUodXNlUHJpb3JpdHlDb25uZWN0b3IoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0eXBlUGFyYW0gVCAtIEEgdHlwZSBhcmd1bWVudCBtdXN0IG9ubHkgYmUgcHJvdmlkZWQgaWYgb25lIG9yIG1vcmUgb2YgdGhlIGNvbm5lY3RvcnMgcGFzc2VkIHRvXG4gICAgICogZ2V0UHJpb3JpdHlDb25uZWN0b3IgaXMgdXNpbmcgYGNvbm5lY3Rvci5jdXN0b21Qcm92aWRlcmAsIGluIHdoaWNoIGNhc2UgaXQgbXVzdCBtYXRjaCBldmVyeSBwb3NzaWJsZSB0eXBlIG9mIHRoaXNcbiAgICAgKiBwcm9wZXJ0eSwgb3ZlciBhbGwgY29ubmVjdG9ycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1c2VQcmlvcml0eVByb3ZpZGVyKG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIHVzZVNlbGVjdGVkUHJvdmlkZXIodXNlUHJpb3JpdHlDb25uZWN0b3IoKSwgbmV0d29yayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVByaW9yaXR5RU5TTmFtZXMocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIHVzZVNlbGVjdGVkRU5TTmFtZXModXNlUHJpb3JpdHlDb25uZWN0b3IoKSwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VQcmlvcml0eUVOU05hbWUocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIHVzZVNlbGVjdGVkRU5TTmFtZSh1c2VQcmlvcml0eUNvbm5lY3RvcigpLCBwcm92aWRlcik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVNlbGVjdGVkU3RvcmUsXG4gICAgICAgIHVzZVNlbGVjdGVkQ2hhaW5JZCxcbiAgICAgICAgdXNlU2VsZWN0ZWRBY2NvdW50cyxcbiAgICAgICAgdXNlU2VsZWN0ZWRJc0FjdGl2YXRpbmcsXG4gICAgICAgIHVzZVNlbGVjdGVkQWNjb3VudCxcbiAgICAgICAgdXNlU2VsZWN0ZWRJc0FjdGl2ZSxcbiAgICAgICAgdXNlU2VsZWN0ZWRQcm92aWRlcixcbiAgICAgICAgdXNlU2VsZWN0ZWRFTlNOYW1lcyxcbiAgICAgICAgdXNlU2VsZWN0ZWRFTlNOYW1lLFxuICAgICAgICB1c2VQcmlvcml0eUNvbm5lY3RvcixcbiAgICAgICAgdXNlUHJpb3JpdHlTdG9yZSxcbiAgICAgICAgdXNlUHJpb3JpdHlDaGFpbklkLFxuICAgICAgICB1c2VQcmlvcml0eUFjY291bnRzLFxuICAgICAgICB1c2VQcmlvcml0eUlzQWN0aXZhdGluZyxcbiAgICAgICAgdXNlUHJpb3JpdHlBY2NvdW50LFxuICAgICAgICB1c2VQcmlvcml0eUlzQWN0aXZlLFxuICAgICAgICB1c2VQcmlvcml0eVByb3ZpZGVyLFxuICAgICAgICB1c2VQcmlvcml0eUVOU05hbWVzLFxuICAgICAgICB1c2VQcmlvcml0eUVOU05hbWUsXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0UHJpb3JpdHlDb25uZWN0b3IgPSBnZXRQcmlvcml0eUNvbm5lY3RvcjtcbmNvbnN0IENIQUlOX0lEID0gKHsgY2hhaW5JZCB9KSA9PiBjaGFpbklkO1xuY29uc3QgQUNDT1VOVFMgPSAoeyBhY2NvdW50cyB9KSA9PiBhY2NvdW50cztcbmNvbnN0IEFDVElWQVRJTkcgPSAoeyBhY3RpdmF0aW5nIH0pID0+IGFjdGl2YXRpbmc7XG5jb25zdCBBQ0NPVU5UU19FUVVBTElUWV9DSEVDS0VSID0gKG9sZEFjY291bnRzLCBuZXdBY2NvdW50cykgPT4gKG9sZEFjY291bnRzID09PSB1bmRlZmluZWQgJiYgbmV3QWNjb3VudHMgPT09IHVuZGVmaW5lZCkgfHxcbiAgICAob2xkQWNjb3VudHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBvbGRBY2NvdW50cy5sZW5ndGggPT09IChuZXdBY2NvdW50cyA9PT0gbnVsbCB8fCBuZXdBY2NvdW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV3QWNjb3VudHMubGVuZ3RoKSAmJlxuICAgICAgICBvbGRBY2NvdW50cy5ldmVyeSgob2xkQWNjb3VudCwgaSkgPT4gb2xkQWNjb3VudCA9PT0gbmV3QWNjb3VudHNbaV0pKTtcbmZ1bmN0aW9uIGdldFN0YXRlSG9va3Moc3RvcmUpIHtcbiAgICBmdW5jdGlvbiB1c2VDaGFpbklkKCkge1xuICAgICAgICByZXR1cm4gKDAsIHp1c3RhbmRfMS51c2VTdG9yZSkoc3RvcmUsIENIQUlOX0lEKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlQWNjb3VudHMoKSB7XG4gICAgICAgIHJldHVybiAoMCwgdHJhZGl0aW9uYWxfMS51c2VTdG9yZVdpdGhFcXVhbGl0eUZuKShzdG9yZSwgQUNDT1VOVFMsIEFDQ09VTlRTX0VRVUFMSVRZX0NIRUNLRVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VJc0FjdGl2YXRpbmcoKSB7XG4gICAgICAgIHJldHVybiAoMCwgenVzdGFuZF8xLnVzZVN0b3JlKShzdG9yZSwgQUNUSVZBVElORyk7XG4gICAgfVxuICAgIHJldHVybiB7IHVzZUNoYWluSWQsIHVzZUFjY291bnRzLCB1c2VJc0FjdGl2YXRpbmcgfTtcbn1cbmZ1bmN0aW9uIGdldERlcml2ZWRIb29rcyh7IHVzZUNoYWluSWQsIHVzZUFjY291bnRzLCB1c2VJc0FjdGl2YXRpbmcgfSkge1xuICAgIGZ1bmN0aW9uIHVzZUFjY291bnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHVzZUFjY291bnRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlSXNBY3RpdmUoKSB7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSB1c2VDaGFpbklkKCk7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gdXNlQWNjb3VudHMoKTtcbiAgICAgICAgY29uc3QgYWN0aXZhdGluZyA9IHVzZUlzQWN0aXZhdGluZygpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZUlzQWN0aXZlKHtcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgICAgIGFjdGl2YXRpbmcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyB1c2VBY2NvdW50LCB1c2VJc0FjdGl2ZSB9O1xufVxuLyoqXG4gKiBAcmV0dXJucyBFTlNOYW1lcyAtIEFuIGFycmF5IG9mIGxlbmd0aCBgYWNjb3VudHMubGVuZ3RoYCB3aGljaCBjb250YWlucyBlbnRyaWVzIHdoaWNoIGFyZSBlaXRoZXIgYWxsIGB1bmRlZmluZWRgLFxuICogaW5kaWNhdGVkIHRoYXQgbmFtZXMgY2Fubm90IGJlIGZldGNoZWQgYmVjYXVzZSB0aGVyZSdzIG5vIHByb3ZpZGVyLCBvciB0aGV5J3JlIGluIHRoZSBwcm9jZXNzIG9mIGJlaW5nIGZldGNoZWQsXG4gKiBvciBgc3RyaW5nIHwgbnVsbGAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIGFuIEVOUyBuYW1lIGhhcyBiZWVuIHNldCBmb3IgdGhlIGFjY291bnQgaW4gcXVlc3Rpb24gb3Igbm90LlxuICovXG5mdW5jdGlvbiB1c2VFTlMocHJvdmlkZXIsIGFjY291bnRzID0gW10pIHtcbiAgICBjb25zdCBbRU5TTmFtZXMsIHNldEVOU05hbWVzXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKSgpO1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgICAgICBpZiAocHJvdmlkZXIgJiYgYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgc3RhbGUgPSBmYWxzZTtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKGFjY291bnRzLm1hcCgoYWNjb3VudCkgPT4gcHJvdmlkZXIubG9va3VwQWRkcmVzcyhhY2NvdW50KSkpXG4gICAgICAgICAgICAgICAgLnRoZW4oKEVOU05hbWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgc2V0RU5TTmFtZXMoRU5TTmFtZXMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnQ291bGQgbm90IGZldGNoIEVOUyBuYW1lcycsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBzZXRFTlNOYW1lcyhuZXcgQXJyYXkoYWNjb3VudHMubGVuZ3RoKS5maWxsKG51bGwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBzdGFsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2V0RU5TTmFtZXModW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbcHJvdmlkZXIsIGFjY291bnRzXSk7XG4gICAgcmV0dXJuIEVOU05hbWVzICE9PSBudWxsICYmIEVOU05hbWVzICE9PSB2b2lkIDAgPyBFTlNOYW1lcyA6IG5ldyBBcnJheShhY2NvdW50cy5sZW5ndGgpLmZpbGwodW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGdldEF1Z21lbnRlZEhvb2tzKGNvbm5lY3RvciwgeyB1c2VBY2NvdW50cywgdXNlQ2hhaW5JZCB9LCB7IHVzZUFjY291bnQsIHVzZUlzQWN0aXZlIH0pIHtcbiAgICAvKipcbiAgICAgKiBBdm9pZCB0eXBlIGVyYXN1cmUgYnkgcmV0dXJuaW5nIHRoZSBtb3N0IHF1YWxpZmllZCB0eXBlIGlmIG5vdCBvdGhlcndpc2Ugc2V0LlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uJ3MgcmV0dXJuIHR5cGUgaXMgYFQgfCB1bmRlZmluZWRgLCBidXQgdGhlcmUgaXMgYSBjb2RlIHBhdGhcbiAgICAgKiB0aGF0IHJldHVybnMgYSBXZWIzUHJvdmlkZXIsIHdoaWNoIGNvdWxkIGNvbmZsaWN0IHdpdGggYSB1c2VyLXByb3ZpZGVkIFQuIFNvLFxuICAgICAqIGl0J3MgaW1wb3J0YW50IHRoYXQgdXNlcnMgb25seSBwcm92aWRlIGFuIG92ZXJyaWRlIGZvciBUIGlmIHRoZXkga25vdyB0aGF0XG4gICAgICogYGNvbm5lY3Rvci5jdXN0b21Qcm92aWRlcmAgaXMgZ29pbmcgdG8gYmUgZGVmaW5lZCBhbmQgb2YgdHlwZSBULlxuICAgICAqXG4gICAgICogQHR5cGVQYXJhbSBUIC0gQSB0eXBlIGFyZ3VtZW50IG11c3Qgb25seSBiZSBwcm92aWRlZCBpZiB1c2luZyBgY29ubmVjdG9yLmN1c3RvbVByb3ZpZGVyYCwgaW4gd2hpY2ggY2FzZSBpdFxuICAgICAqIG11c3QgbWF0Y2ggdGhlIHR5cGUgb2YgdGhpcyBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1c2VQcm92aWRlcihuZXR3b3JrLCBlbmFibGVkID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBpc0FjdGl2ZSA9IHVzZUlzQWN0aXZlKCk7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSB1c2VDaGFpbklkKCk7XG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IFByb3ZpZGVyIGlzIGdvaW5nIHRvIGJlIGF2YWlsYWJsZSB3aGVuIGxvYWRlZCBpZiBAZXRoZXJzcHJvamVjdC9wcm92aWRlcnMgaXMgaW5zdGFsbGVkXG4gICAgICAgIGNvbnN0IFtsb2FkZWQsIHNldExvYWRlZF0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoRHluYW1pY1Byb3ZpZGVyICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChsb2FkZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHN0YWxlID0gZmFsc2U7XG4gICAgICAgICAgICB2b2lkIGltcG9ydFByb3ZpZGVyKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgc2V0TG9hZGVkKHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFtsb2FkZWRdKTtcbiAgICAgICAgcmV0dXJuICgwLCByZWFjdF8xLnVzZU1lbW8pKCgpID0+IHtcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSBjb25uZWN0b3JzIHJlbWFpbiBmcmVzaCwgd2UgY29uZGl0aW9uIHJlLXJlbmRlcnMgb24gbG9hZGVkLCBpc0FjdGl2ZSBhbmQgY2hhaW5JZFxuICAgICAgICAgICAgdm9pZCBsb2FkZWQgJiYgaXNBY3RpdmUgJiYgY2hhaW5JZDtcbiAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rvci5jdXN0b21Qcm92aWRlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rvci5jdXN0b21Qcm92aWRlcjtcbiAgICAgICAgICAgICAgICAvLyBzZWUgdHNkb2Mgbm90ZSBhYm92ZSBmb3IgcmV0dXJuIHR5cGUgZXhwbGFuYXRpb24uXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoRHluYW1pY1Byb3ZpZGVyICYmIGNvbm5lY3Rvci5wcm92aWRlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEeW5hbWljUHJvdmlkZXIoY29ubmVjdG9yLnByb3ZpZGVyLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW2xvYWRlZCwgZW5hYmxlZCwgaXNBY3RpdmUsIGNoYWluSWQsIG5ldHdvcmtdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlRU5TTmFtZXMocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSB1c2VBY2NvdW50cygpO1xuICAgICAgICByZXR1cm4gdXNlRU5TKHByb3ZpZGVyLCBhY2NvdW50cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZUVOU05hbWUocHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBhY2NvdW50ID0gdXNlQWNjb3VudCgpO1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKCgpID0+IChhY2NvdW50ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBbYWNjb3VudF0pLCBbYWNjb3VudF0pO1xuICAgICAgICByZXR1cm4gKF9hID0gdXNlRU5TKHByb3ZpZGVyLCBhY2NvdW50cykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdXNlUHJvdmlkZXIsIHVzZUVOU05hbWVzLCB1c2VFTlNOYW1lIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-react/core/dist/hooks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@web3-react/core/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@web3-react/core/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./hooks */ \"(ssr)/./node_modules/@web3-react/core/dist/hooks.js\"), exports);\n__exportStar(__webpack_require__(/*! ./mocks */ \"(ssr)/./node_modules/@web3-react/core/dist/mocks.js\"), exports);\n__exportStar(__webpack_require__(/*! ./provider */ \"(ssr)/./node_modules/@web3-react/core/dist/provider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3QvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsb0VBQVM7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLDBFQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FsbGV0LWNvbm5lY3Rpb25zLy4vbm9kZV9tb2R1bGVzL0B3ZWIzLXJlYWN0L2NvcmUvZGlzdC9pbmRleC5qcz81N2Q4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3NcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vY2tzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm92aWRlclwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-react/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@web3-react/core/dist/mocks.js":
/*!*****************************************************!*\
  !*** ./node_modules/@web3-react/core/dist/mocks.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MockEIP1193Provider = void 0;\nconst eventemitter3_1 = __webpack_require__(/*! eventemitter3 */ \"(ssr)/./node_modules/eventemitter3/index.js\");\nclass MockEIP1193Provider extends eventemitter3_1.EventEmitter {\n    constructor() {\n        super(...arguments);\n        this.eth_chainId = jest.fn((chainId) => chainId);\n        this.eth_accounts = jest.fn((accounts) => accounts);\n        this.eth_requestAccounts = jest.fn((accounts) => accounts);\n    }\n    request(x) {\n        // make sure to throw if we're \"not connected\"\n        if (!this.chainId)\n            return Promise.reject(new Error());\n        switch (x.method) {\n            case 'eth_chainId':\n                return Promise.resolve(this.eth_chainId(this.chainId));\n            case 'eth_accounts':\n                return Promise.resolve(this.eth_accounts(this.accounts));\n            case 'eth_requestAccounts':\n                return Promise.resolve(this.eth_requestAccounts(this.accounts));\n            default:\n                throw new Error(`Method not supported on mock: ${JSON.stringify(x)}`);\n        }\n    }\n    emitConnect(chainId) {\n        this.emit('connect', { chainId });\n    }\n    emitDisconnect(error) {\n        this.emit('disconnect', error);\n    }\n    emitChainChanged(chainId) {\n        this.emit('chainChanged', chainId);\n    }\n    emitAccountsChanged(accounts) {\n        this.emit('accountsChanged', accounts);\n    }\n}\nexports.MockEIP1193Provider = MockEIP1193Provider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3QvY29yZS9kaXN0L21vY2tzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQix3QkFBd0IsbUJBQU8sQ0FBQyxrRUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxrQkFBa0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dhbGxldC1jb25uZWN0aW9ucy8uL25vZGVfbW9kdWxlcy9Ad2ViMy1yZWFjdC9jb3JlL2Rpc3QvbW9ja3MuanM/MWFhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW9ja0VJUDExOTNQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50ZW1pdHRlcjNfMSA9IHJlcXVpcmUoXCJldmVudGVtaXR0ZXIzXCIpO1xuY2xhc3MgTW9ja0VJUDExOTNQcm92aWRlciBleHRlbmRzIGV2ZW50ZW1pdHRlcjNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmV0aF9jaGFpbklkID0gamVzdC5mbigoY2hhaW5JZCkgPT4gY2hhaW5JZCk7XG4gICAgICAgIHRoaXMuZXRoX2FjY291bnRzID0gamVzdC5mbigoYWNjb3VudHMpID0+IGFjY291bnRzKTtcbiAgICAgICAgdGhpcy5ldGhfcmVxdWVzdEFjY291bnRzID0gamVzdC5mbigoYWNjb3VudHMpID0+IGFjY291bnRzKTtcbiAgICB9XG4gICAgcmVxdWVzdCh4KSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byB0aHJvdyBpZiB3ZSdyZSBcIm5vdCBjb25uZWN0ZWRcIlxuICAgICAgICBpZiAoIXRoaXMuY2hhaW5JZClcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoKSk7XG4gICAgICAgIHN3aXRjaCAoeC5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ2V0aF9jaGFpbklkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZXRoX2NoYWluSWQodGhpcy5jaGFpbklkKSk7XG4gICAgICAgICAgICBjYXNlICdldGhfYWNjb3VudHMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5ldGhfYWNjb3VudHModGhpcy5hY2NvdW50cykpO1xuICAgICAgICAgICAgY2FzZSAnZXRoX3JlcXVlc3RBY2NvdW50cyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmV0aF9yZXF1ZXN0QWNjb3VudHModGhpcy5hY2NvdW50cykpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ldGhvZCBub3Qgc3VwcG9ydGVkIG9uIG1vY2s6ICR7SlNPTi5zdHJpbmdpZnkoeCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdENvbm5lY3QoY2hhaW5JZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCB7IGNoYWluSWQgfSk7XG4gICAgfVxuICAgIGVtaXREaXNjb25uZWN0KGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIGVycm9yKTtcbiAgICB9XG4gICAgZW1pdENoYWluQ2hhbmdlZChjaGFpbklkKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnY2hhaW5DaGFuZ2VkJywgY2hhaW5JZCk7XG4gICAgfVxuICAgIGVtaXRBY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdhY2NvdW50c0NoYW5nZWQnLCBhY2NvdW50cyk7XG4gICAgfVxufVxuZXhwb3J0cy5Nb2NrRUlQMTE5M1Byb3ZpZGVyID0gTW9ja0VJUDExOTNQcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-react/core/dist/mocks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@web3-react/core/dist/provider.js":
/*!********************************************************!*\
  !*** ./node_modules/@web3-react/core/dist/provider.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.useWeb3React = exports.Web3ReactProvider = void 0;\nconst react_1 = __importStar(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nconst hooks_1 = __webpack_require__(/*! ./hooks */ \"(ssr)/./node_modules/@web3-react/core/dist/hooks.js\");\nconst Web3Context = (0, react_1.createContext)(undefined);\nfunction Web3ReactProvider({ children, connectors, connectorOverride, network, lookupENS = true, }) {\n    const cachedConnectors = (0, react_1.useRef)(connectors);\n    // because we're calling `getPriorityConnector` with these connectors, we need to ensure that they're not changing in place\n    if (connectors.length != cachedConnectors.current.length ||\n        connectors.some((connector, i) => {\n            const cachedConnector = cachedConnectors.current[i];\n            // because a \"connector\" is actually an array, we want to be sure to only perform an equality check on the actual Connector\n            // class instance, to see if they're the same object\n            return connector[0] !== cachedConnector[0];\n        }))\n        throw new Error('The connectors prop passed to Web3ReactProvider must be referentially static. If connectors is changing, try providing a key prop to Web3ReactProvider that changes every time connectors changes.');\n    const hooks = (0, hooks_1.getPriorityConnector)(...connectors);\n    const { usePriorityConnector, useSelectedChainId, useSelectedAccounts, useSelectedIsActivating, useSelectedAccount, useSelectedIsActive, useSelectedProvider, useSelectedENSNames, useSelectedENSName, } = hooks;\n    const priorityConnector = usePriorityConnector();\n    const connector = connectorOverride !== null && connectorOverride !== void 0 ? connectorOverride : priorityConnector;\n    const chainId = useSelectedChainId(connector);\n    const accounts = useSelectedAccounts(connector);\n    const isActivating = useSelectedIsActivating(connector);\n    const account = useSelectedAccount(connector);\n    const isActive = useSelectedIsActive(connector);\n    // note that we've omitted a <T extends BaseProvider = Web3Provider> generic type\n    // in Web3ReactProvider, and thus can't pass T through to useSelectedProvider below.\n    // this is because if we did so, the type of provider would include T, but that would\n    // conflict because Web3Context can't take a generic. however, this isn't particularly\n    // important, because useWeb3React (below) is manually typed\n    const provider = useSelectedProvider(connector, network);\n    const ENSNames = useSelectedENSNames(connector, lookupENS ? provider : undefined);\n    const ENSName = useSelectedENSName(connector, lookupENS ? provider : undefined);\n    return (react_1.default.createElement(Web3Context.Provider, { value: {\n            connector,\n            chainId,\n            accounts,\n            isActivating,\n            account,\n            isActive,\n            provider,\n            ENSNames,\n            ENSName,\n            hooks,\n        } }, children));\n}\nexports.Web3ReactProvider = Web3ReactProvider;\nfunction useWeb3React() {\n    const context = (0, react_1.useContext)(Web3Context);\n    if (!context)\n        throw Error('useWeb3React can only be used within the Web3ReactProvider component');\n    return context;\n}\nexports.useWeb3React = useWeb3React;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3QvY29yZS9kaXN0L3Byb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyx5QkFBeUI7QUFDaEQsNkJBQTZCLG1CQUFPLENBQUMsd0dBQU87QUFDNUMsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQVM7QUFDakM7QUFDQSw2QkFBNkIscUVBQXFFO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVksaU1BQWlNO0FBQzdNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93YWxsZXQtY29ubmVjdGlvbnMvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3QvY29yZS9kaXN0L3Byb3ZpZGVyLmpzP2NkMzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXNlV2ViM1JlYWN0ID0gZXhwb3J0cy5XZWIzUmVhY3RQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IGhvb2tzXzEgPSByZXF1aXJlKFwiLi9ob29rc1wiKTtcbmNvbnN0IFdlYjNDb250ZXh0ID0gKDAsIHJlYWN0XzEuY3JlYXRlQ29udGV4dCkodW5kZWZpbmVkKTtcbmZ1bmN0aW9uIFdlYjNSZWFjdFByb3ZpZGVyKHsgY2hpbGRyZW4sIGNvbm5lY3RvcnMsIGNvbm5lY3Rvck92ZXJyaWRlLCBuZXR3b3JrLCBsb29rdXBFTlMgPSB0cnVlLCB9KSB7XG4gICAgY29uc3QgY2FjaGVkQ29ubmVjdG9ycyA9ICgwLCByZWFjdF8xLnVzZVJlZikoY29ubmVjdG9ycyk7XG4gICAgLy8gYmVjYXVzZSB3ZSdyZSBjYWxsaW5nIGBnZXRQcmlvcml0eUNvbm5lY3RvcmAgd2l0aCB0aGVzZSBjb25uZWN0b3JzLCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHRoZXkncmUgbm90IGNoYW5naW5nIGluIHBsYWNlXG4gICAgaWYgKGNvbm5lY3RvcnMubGVuZ3RoICE9IGNhY2hlZENvbm5lY3RvcnMuY3VycmVudC5sZW5ndGggfHxcbiAgICAgICAgY29ubmVjdG9ycy5zb21lKChjb25uZWN0b3IsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZENvbm5lY3RvciA9IGNhY2hlZENvbm5lY3RvcnMuY3VycmVudFtpXTtcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgYSBcImNvbm5lY3RvclwiIGlzIGFjdHVhbGx5IGFuIGFycmF5LCB3ZSB3YW50IHRvIGJlIHN1cmUgdG8gb25seSBwZXJmb3JtIGFuIGVxdWFsaXR5IGNoZWNrIG9uIHRoZSBhY3R1YWwgQ29ubmVjdG9yXG4gICAgICAgICAgICAvLyBjbGFzcyBpbnN0YW5jZSwgdG8gc2VlIGlmIHRoZXkncmUgdGhlIHNhbWUgb2JqZWN0XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdG9yWzBdICE9PSBjYWNoZWRDb25uZWN0b3JbMF07XG4gICAgICAgIH0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjb25uZWN0b3JzIHByb3AgcGFzc2VkIHRvIFdlYjNSZWFjdFByb3ZpZGVyIG11c3QgYmUgcmVmZXJlbnRpYWxseSBzdGF0aWMuIElmIGNvbm5lY3RvcnMgaXMgY2hhbmdpbmcsIHRyeSBwcm92aWRpbmcgYSBrZXkgcHJvcCB0byBXZWIzUmVhY3RQcm92aWRlciB0aGF0IGNoYW5nZXMgZXZlcnkgdGltZSBjb25uZWN0b3JzIGNoYW5nZXMuJyk7XG4gICAgY29uc3QgaG9va3MgPSAoMCwgaG9va3NfMS5nZXRQcmlvcml0eUNvbm5lY3RvcikoLi4uY29ubmVjdG9ycyk7XG4gICAgY29uc3QgeyB1c2VQcmlvcml0eUNvbm5lY3RvciwgdXNlU2VsZWN0ZWRDaGFpbklkLCB1c2VTZWxlY3RlZEFjY291bnRzLCB1c2VTZWxlY3RlZElzQWN0aXZhdGluZywgdXNlU2VsZWN0ZWRBY2NvdW50LCB1c2VTZWxlY3RlZElzQWN0aXZlLCB1c2VTZWxlY3RlZFByb3ZpZGVyLCB1c2VTZWxlY3RlZEVOU05hbWVzLCB1c2VTZWxlY3RlZEVOU05hbWUsIH0gPSBob29rcztcbiAgICBjb25zdCBwcmlvcml0eUNvbm5lY3RvciA9IHVzZVByaW9yaXR5Q29ubmVjdG9yKCk7XG4gICAgY29uc3QgY29ubmVjdG9yID0gY29ubmVjdG9yT3ZlcnJpZGUgIT09IG51bGwgJiYgY29ubmVjdG9yT3ZlcnJpZGUgIT09IHZvaWQgMCA/IGNvbm5lY3Rvck92ZXJyaWRlIDogcHJpb3JpdHlDb25uZWN0b3I7XG4gICAgY29uc3QgY2hhaW5JZCA9IHVzZVNlbGVjdGVkQ2hhaW5JZChjb25uZWN0b3IpO1xuICAgIGNvbnN0IGFjY291bnRzID0gdXNlU2VsZWN0ZWRBY2NvdW50cyhjb25uZWN0b3IpO1xuICAgIGNvbnN0IGlzQWN0aXZhdGluZyA9IHVzZVNlbGVjdGVkSXNBY3RpdmF0aW5nKGNvbm5lY3Rvcik7XG4gICAgY29uc3QgYWNjb3VudCA9IHVzZVNlbGVjdGVkQWNjb3VudChjb25uZWN0b3IpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gdXNlU2VsZWN0ZWRJc0FjdGl2ZShjb25uZWN0b3IpO1xuICAgIC8vIG5vdGUgdGhhdCB3ZSd2ZSBvbWl0dGVkIGEgPFQgZXh0ZW5kcyBCYXNlUHJvdmlkZXIgPSBXZWIzUHJvdmlkZXI+IGdlbmVyaWMgdHlwZVxuICAgIC8vIGluIFdlYjNSZWFjdFByb3ZpZGVyLCBhbmQgdGh1cyBjYW4ndCBwYXNzIFQgdGhyb3VnaCB0byB1c2VTZWxlY3RlZFByb3ZpZGVyIGJlbG93LlxuICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBpZiB3ZSBkaWQgc28sIHRoZSB0eXBlIG9mIHByb3ZpZGVyIHdvdWxkIGluY2x1ZGUgVCwgYnV0IHRoYXQgd291bGRcbiAgICAvLyBjb25mbGljdCBiZWNhdXNlIFdlYjNDb250ZXh0IGNhbid0IHRha2UgYSBnZW5lcmljLiBob3dldmVyLCB0aGlzIGlzbid0IHBhcnRpY3VsYXJseVxuICAgIC8vIGltcG9ydGFudCwgYmVjYXVzZSB1c2VXZWIzUmVhY3QgKGJlbG93KSBpcyBtYW51YWxseSB0eXBlZFxuICAgIGNvbnN0IHByb3ZpZGVyID0gdXNlU2VsZWN0ZWRQcm92aWRlcihjb25uZWN0b3IsIG5ldHdvcmspO1xuICAgIGNvbnN0IEVOU05hbWVzID0gdXNlU2VsZWN0ZWRFTlNOYW1lcyhjb25uZWN0b3IsIGxvb2t1cEVOUyA/IHByb3ZpZGVyIDogdW5kZWZpbmVkKTtcbiAgICBjb25zdCBFTlNOYW1lID0gdXNlU2VsZWN0ZWRFTlNOYW1lKGNvbm5lY3RvciwgbG9va3VwRU5TID8gcHJvdmlkZXIgOiB1bmRlZmluZWQpO1xuICAgIHJldHVybiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoV2ViM0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHtcbiAgICAgICAgICAgIGNvbm5lY3RvcixcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgICAgIGlzQWN0aXZhdGluZyxcbiAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICBpc0FjdGl2ZSxcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgRU5TTmFtZXMsXG4gICAgICAgICAgICBFTlNOYW1lLFxuICAgICAgICAgICAgaG9va3MsXG4gICAgICAgIH0gfSwgY2hpbGRyZW4pKTtcbn1cbmV4cG9ydHMuV2ViM1JlYWN0UHJvdmlkZXIgPSBXZWIzUmVhY3RQcm92aWRlcjtcbmZ1bmN0aW9uIHVzZVdlYjNSZWFjdCgpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKDAsIHJlYWN0XzEudXNlQ29udGV4dCkoV2ViM0NvbnRleHQpO1xuICAgIGlmICghY29udGV4dClcbiAgICAgICAgdGhyb3cgRXJyb3IoJ3VzZVdlYjNSZWFjdCBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgV2ViM1JlYWN0UHJvdmlkZXIgY29tcG9uZW50Jyk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5leHBvcnRzLnVzZVdlYjNSZWFjdCA9IHVzZVdlYjNSZWFjdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-react/core/dist/provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@web3-react/metamask/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@web3-react/metamask/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MetaMask = exports.NoMetaMaskError = void 0;\nconst types_1 = __webpack_require__(/*! @web3-react/types */ \"(ssr)/./node_modules/@web3-react/types/dist/index.js\");\nclass NoMetaMaskError extends Error {\n    constructor() {\n        super('MetaMask not installed');\n        this.name = NoMetaMaskError.name;\n        Object.setPrototypeOf(this, NoMetaMaskError.prototype);\n    }\n}\nexports.NoMetaMaskError = NoMetaMaskError;\nfunction parseChainId(chainId) {\n    return Number.parseInt(chainId, 16);\n}\nclass MetaMask extends types_1.Connector {\n    constructor({ actions, options, onError }) {\n        super(actions, onError);\n        this.options = options;\n    }\n    isomorphicInitialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.eagerConnection)\n                return;\n            return (this.eagerConnection = Promise.resolve().then(() => __importStar(__webpack_require__(/*! @metamask/detect-provider */ \"(ssr)/./node_modules/@metamask/detect-provider/dist/index.js\"))).then((m) => __awaiter(this, void 0, void 0, function* () {\n                var _a, _b;\n                const provider = yield m.default(this.options);\n                if (provider) {\n                    this.provider = provider;\n                    // handle the case when e.g. metamask and coinbase wallet are both installed\n                    if ((_a = this.provider.providers) === null || _a === void 0 ? void 0 : _a.length) {\n                        this.provider = (_b = this.provider.providers.find((p) => p.isMetaMask)) !== null && _b !== void 0 ? _b : this.provider.providers[0];\n                    }\n                    this.provider.on('connect', ({ chainId }) => {\n                        this.actions.update({ chainId: parseChainId(chainId) });\n                    });\n                    this.provider.on('disconnect', (error) => {\n                        var _a;\n                        // 1013 indicates that MetaMask is attempting to reestablish the connection\n                        // https://github.com/MetaMask/providers/releases/tag/v8.0.0\n                        if (error.code === 1013) {\n                            console.debug('MetaMask logged connection error 1013: \"Try again later\"');\n                            return;\n                        }\n                        this.actions.resetState();\n                        (_a = this.onError) === null || _a === void 0 ? void 0 : _a.call(this, error);\n                    });\n                    this.provider.on('chainChanged', (chainId) => {\n                        this.actions.update({ chainId: parseChainId(chainId) });\n                    });\n                    this.provider.on('accountsChanged', (accounts) => {\n                        if (accounts.length === 0) {\n                            // handle this edge case by disconnecting\n                            this.actions.resetState();\n                        }\n                        else {\n                            this.actions.update({ accounts });\n                        }\n                    });\n                }\n            })));\n        });\n    }\n    /** {@inheritdoc Connector.connectEagerly} */\n    connectEagerly() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cancelActivation = this.actions.startActivation();\n            try {\n                yield this.isomorphicInitialize();\n                if (!this.provider)\n                    return cancelActivation();\n                // Wallets may resolve eth_chainId and hang on eth_accounts pending user interaction, which may include changing\n                // chains; they should be requested serially, with accounts first, so that the chainId can settle.\n                const accounts = (yield this.provider.request({ method: 'eth_accounts' }));\n                if (!accounts.length)\n                    throw new Error('No accounts returned');\n                const chainId = (yield this.provider.request({ method: 'eth_chainId' }));\n                this.actions.update({ chainId: parseChainId(chainId), accounts });\n            }\n            catch (error) {\n                console.debug('Could not connect eagerly', error);\n                // we should be able to use `cancelActivation` here, but on mobile, metamask emits a 'connect'\n                // event, meaning that chainId is updated, and cancelActivation doesn't work because an intermediary\n                // update has occurred, so we reset state instead\n                this.actions.resetState();\n            }\n        });\n    }\n    /**\n     * Initiates a connection.\n     *\n     * @param desiredChainIdOrChainParameters - If defined, indicates the desired chain to connect to. If the user is\n     * already connected to this chain, no additional steps will be taken. Otherwise, the user will be prompted to switch\n     * to the chain, if one of two conditions is met: either they already have it added in their extension, or the\n     * argument is of type AddEthereumChainParameter, in which case the user will be prompted to add the chain with the\n     * specified parameters first, before being prompted to switch.\n     */\n    activate(desiredChainIdOrChainParameters) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            let cancelActivation;\n            if (!((_b = (_a = this.provider) === null || _a === void 0 ? void 0 : _a.isConnected) === null || _b === void 0 ? void 0 : _b.call(_a)))\n                cancelActivation = this.actions.startActivation();\n            return this.isomorphicInitialize()\n                .then(() => __awaiter(this, void 0, void 0, function* () {\n                if (!this.provider)\n                    throw new NoMetaMaskError();\n                // Wallets may resolve eth_chainId and hang on eth_accounts pending user interaction, which may include changing\n                // chains; they should be requested serially, with accounts first, so that the chainId can settle.\n                const accounts = (yield this.provider.request({ method: 'eth_requestAccounts' }));\n                const chainId = (yield this.provider.request({ method: 'eth_chainId' }));\n                const receivedChainId = parseChainId(chainId);\n                const desiredChainId = typeof desiredChainIdOrChainParameters === 'number'\n                    ? desiredChainIdOrChainParameters\n                    : desiredChainIdOrChainParameters === null || desiredChainIdOrChainParameters === void 0 ? void 0 : desiredChainIdOrChainParameters.chainId;\n                // if there's no desired chain, or it's equal to the received, update\n                if (!desiredChainId || receivedChainId === desiredChainId)\n                    return this.actions.update({ chainId: receivedChainId, accounts });\n                const desiredChainIdHex = `0x${desiredChainId.toString(16)}`;\n                // if we're here, we can try to switch networks\n                return this.provider\n                    .request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: desiredChainIdHex }],\n                })\n                    .catch((error) => {\n                    var _a, _b;\n                    // https://github.com/MetaMask/metamask-mobile/issues/3312#issuecomment-1065923294\n                    const errorCode = ((_b = (_a = error.data) === null || _a === void 0 ? void 0 : _a.originalError) === null || _b === void 0 ? void 0 : _b.code) || error.code;\n                    // 4902 indicates that the chain has not been added to MetaMask and wallet_addEthereumChain needs to be called\n                    // https://docs.metamask.io/guide/rpc-api.html#wallet-switchethereumchain\n                    if (errorCode === 4902 && typeof desiredChainIdOrChainParameters !== 'number') {\n                        if (!this.provider)\n                            throw new Error('No provider');\n                        // if we're here, we can try to add a new network\n                        return this.provider.request({\n                            method: 'wallet_addEthereumChain',\n                            params: [Object.assign(Object.assign({}, desiredChainIdOrChainParameters), { chainId: desiredChainIdHex })],\n                        });\n                    }\n                    throw error;\n                })\n                    .then(() => this.activate(desiredChainId));\n            }))\n                .catch((error) => {\n                cancelActivation === null || cancelActivation === void 0 ? void 0 : cancelActivation();\n                throw error;\n            });\n        });\n    }\n    watchAsset({ address, symbol, decimals, image }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.provider)\n                throw new Error('No provider');\n            return this.provider\n                .request({\n                method: 'wallet_watchAsset',\n                params: {\n                    type: 'ERC20',\n                    options: {\n                        address,\n                        symbol,\n                        decimals,\n                        image, // A string url of the token logo\n                    },\n                },\n            })\n                .then((success) => {\n                if (!success)\n                    throw new Error('Rejected');\n                return true;\n            });\n        });\n    }\n}\nexports.MetaMask = MetaMask;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3QvbWV0YW1hc2svZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLHVCQUF1QjtBQUMxQyxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLG1CQUFPLENBQUMsK0ZBQTJCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RCw4Q0FBOEMsZ0NBQWdDO0FBQzlFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLDhDQUE4QyxnQ0FBZ0M7QUFDOUUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLFNBQVMsc0NBQXNDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsZ0VBQWdFLHdCQUF3QjtBQUN4RjtBQUNBO0FBQ0EsK0RBQStELHVCQUF1QjtBQUN0RixzQ0FBc0MsMENBQTBDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGdFQUFnRSwrQkFBK0I7QUFDL0YsK0RBQStELHVCQUF1QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0NBQW9DO0FBQ3JGLCtDQUErQyw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNEJBQTRCO0FBQzNELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsc0NBQXNDLDRCQUE0QjtBQUNySSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FsbGV0LWNvbm5lY3Rpb25zLy4vbm9kZV9tb2R1bGVzL0B3ZWIzLXJlYWN0L21ldGFtYXNrL2Rpc3QvaW5kZXguanM/ODc2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1ldGFNYXNrID0gZXhwb3J0cy5Ob01ldGFNYXNrRXJyb3IgPSB2b2lkIDA7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIkB3ZWIzLXJlYWN0L3R5cGVzXCIpO1xuY2xhc3MgTm9NZXRhTWFza0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignTWV0YU1hc2sgbm90IGluc3RhbGxlZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSBOb01ldGFNYXNrRXJyb3IubmFtZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIE5vTWV0YU1hc2tFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9NZXRhTWFza0Vycm9yID0gTm9NZXRhTWFza0Vycm9yO1xuZnVuY3Rpb24gcGFyc2VDaGFpbklkKGNoYWluSWQpIHtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KGNoYWluSWQsIDE2KTtcbn1cbmNsYXNzIE1ldGFNYXNrIGV4dGVuZHMgdHlwZXNfMS5Db25uZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgYWN0aW9ucywgb3B0aW9ucywgb25FcnJvciB9KSB7XG4gICAgICAgIHN1cGVyKGFjdGlvbnMsIG9uRXJyb3IpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBpc29tb3JwaGljSW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVhZ2VyQ29ubmVjdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZWFnZXJDb25uZWN0aW9uID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBfX2ltcG9ydFN0YXIocmVxdWlyZSgnQG1ldGFtYXNrL2RldGVjdC1wcm92aWRlcicpKSkudGhlbigobSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCBtLmRlZmF1bHQodGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlbiBlLmcuIG1ldGFtYXNrIGFuZCBjb2luYmFzZSB3YWxsZXQgYXJlIGJvdGggaW5zdGFsbGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLnByb3ZpZGVyLnByb3ZpZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlciA9IChfYiA9IHRoaXMucHJvdmlkZXIucHJvdmlkZXJzLmZpbmQoKHApID0+IHAuaXNNZXRhTWFzaykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMucHJvdmlkZXIucHJvdmlkZXJzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub24oJ2Nvbm5lY3QnLCAoeyBjaGFpbklkIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy51cGRhdGUoeyBjaGFpbklkOiBwYXJzZUNoYWluSWQoY2hhaW5JZCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKCdkaXNjb25uZWN0JywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAxMDEzIGluZGljYXRlcyB0aGF0IE1ldGFNYXNrIGlzIGF0dGVtcHRpbmcgdG8gcmVlc3RhYmxpc2ggdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9wcm92aWRlcnMvcmVsZWFzZXMvdGFnL3Y4LjAuMFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IDEwMTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdNZXRhTWFzayBsb2dnZWQgY29ubmVjdGlvbiBlcnJvciAxMDEzOiBcIlRyeSBhZ2FpbiBsYXRlclwiJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMub25FcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbignY2hhaW5DaGFuZ2VkJywgKGNoYWluSWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy51cGRhdGUoeyBjaGFpbklkOiBwYXJzZUNoYWluSWQoY2hhaW5JZCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKCdhY2NvdW50c0NoYW5nZWQnLCAoYWNjb3VudHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGhpcyBlZGdlIGNhc2UgYnkgZGlzY29ubmVjdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMudXBkYXRlKHsgYWNjb3VudHMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKioge0Bpbmhlcml0ZG9jIENvbm5lY3Rvci5jb25uZWN0RWFnZXJseX0gKi9cbiAgICBjb25uZWN0RWFnZXJseSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbEFjdGl2YXRpb24gPSB0aGlzLmFjdGlvbnMuc3RhcnRBY3RpdmF0aW9uKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuaXNvbW9ycGhpY0luaXRpYWxpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5jZWxBY3RpdmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gV2FsbGV0cyBtYXkgcmVzb2x2ZSBldGhfY2hhaW5JZCBhbmQgaGFuZyBvbiBldGhfYWNjb3VudHMgcGVuZGluZyB1c2VyIGludGVyYWN0aW9uLCB3aGljaCBtYXkgaW5jbHVkZSBjaGFuZ2luZ1xuICAgICAgICAgICAgICAgIC8vIGNoYWluczsgdGhleSBzaG91bGQgYmUgcmVxdWVzdGVkIHNlcmlhbGx5LCB3aXRoIGFjY291bnRzIGZpcnN0LCBzbyB0aGF0IHRoZSBjaGFpbklkIGNhbiBzZXR0bGUuXG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSAoeWllbGQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2FjY291bnRzJyB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWNjb3VudHMgcmV0dXJuZWQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gKHlpZWxkIHRoaXMucHJvdmlkZXIucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9jaGFpbklkJyB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnVwZGF0ZSh7IGNoYWluSWQ6IHBhcnNlQ2hhaW5JZChjaGFpbklkKSwgYWNjb3VudHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdDb3VsZCBub3QgY29ubmVjdCBlYWdlcmx5JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBiZSBhYmxlIHRvIHVzZSBgY2FuY2VsQWN0aXZhdGlvbmAgaGVyZSwgYnV0IG9uIG1vYmlsZSwgbWV0YW1hc2sgZW1pdHMgYSAnY29ubmVjdCdcbiAgICAgICAgICAgICAgICAvLyBldmVudCwgbWVhbmluZyB0aGF0IGNoYWluSWQgaXMgdXBkYXRlZCwgYW5kIGNhbmNlbEFjdGl2YXRpb24gZG9lc24ndCB3b3JrIGJlY2F1c2UgYW4gaW50ZXJtZWRpYXJ5XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGhhcyBvY2N1cnJlZCwgc28gd2UgcmVzZXQgc3RhdGUgaW5zdGVhZFxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZXMgYSBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRlc2lyZWRDaGFpbklkT3JDaGFpblBhcmFtZXRlcnMgLSBJZiBkZWZpbmVkLCBpbmRpY2F0ZXMgdGhlIGRlc2lyZWQgY2hhaW4gdG8gY29ubmVjdCB0by4gSWYgdGhlIHVzZXIgaXNcbiAgICAgKiBhbHJlYWR5IGNvbm5lY3RlZCB0byB0aGlzIGNoYWluLCBubyBhZGRpdGlvbmFsIHN0ZXBzIHdpbGwgYmUgdGFrZW4uIE90aGVyd2lzZSwgdGhlIHVzZXIgd2lsbCBiZSBwcm9tcHRlZCB0byBzd2l0Y2hcbiAgICAgKiB0byB0aGUgY2hhaW4sIGlmIG9uZSBvZiB0d28gY29uZGl0aW9ucyBpcyBtZXQ6IGVpdGhlciB0aGV5IGFscmVhZHkgaGF2ZSBpdCBhZGRlZCBpbiB0aGVpciBleHRlbnNpb24sIG9yIHRoZVxuICAgICAqIGFyZ3VtZW50IGlzIG9mIHR5cGUgQWRkRXRoZXJldW1DaGFpblBhcmFtZXRlciwgaW4gd2hpY2ggY2FzZSB0aGUgdXNlciB3aWxsIGJlIHByb21wdGVkIHRvIGFkZCB0aGUgY2hhaW4gd2l0aCB0aGVcbiAgICAgKiBzcGVjaWZpZWQgcGFyYW1ldGVycyBmaXJzdCwgYmVmb3JlIGJlaW5nIHByb21wdGVkIHRvIHN3aXRjaC5cbiAgICAgKi9cbiAgICBhY3RpdmF0ZShkZXNpcmVkQ2hhaW5JZE9yQ2hhaW5QYXJhbWV0ZXJzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgY2FuY2VsQWN0aXZhdGlvbjtcbiAgICAgICAgICAgIGlmICghKChfYiA9IChfYSA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Nvbm5lY3RlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKSlcbiAgICAgICAgICAgICAgICBjYW5jZWxBY3RpdmF0aW9uID0gdGhpcy5hY3Rpb25zLnN0YXJ0QWN0aXZhdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNvbW9ycGhpY0luaXRpYWxpemUoKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb01ldGFNYXNrRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAvLyBXYWxsZXRzIG1heSByZXNvbHZlIGV0aF9jaGFpbklkIGFuZCBoYW5nIG9uIGV0aF9hY2NvdW50cyBwZW5kaW5nIHVzZXIgaW50ZXJhY3Rpb24sIHdoaWNoIG1heSBpbmNsdWRlIGNoYW5naW5nXG4gICAgICAgICAgICAgICAgLy8gY2hhaW5zOyB0aGV5IHNob3VsZCBiZSByZXF1ZXN0ZWQgc2VyaWFsbHksIHdpdGggYWNjb3VudHMgZmlyc3QsIHNvIHRoYXQgdGhlIGNoYWluSWQgY2FuIHNldHRsZS5cbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9ICh5aWVsZCB0aGlzLnByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfcmVxdWVzdEFjY291bnRzJyB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9ICh5aWVsZCB0aGlzLnByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfY2hhaW5JZCcgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVkQ2hhaW5JZCA9IHBhcnNlQ2hhaW5JZChjaGFpbklkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNpcmVkQ2hhaW5JZCA9IHR5cGVvZiBkZXNpcmVkQ2hhaW5JZE9yQ2hhaW5QYXJhbWV0ZXJzID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICA/IGRlc2lyZWRDaGFpbklkT3JDaGFpblBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgOiBkZXNpcmVkQ2hhaW5JZE9yQ2hhaW5QYXJhbWV0ZXJzID09PSBudWxsIHx8IGRlc2lyZWRDaGFpbklkT3JDaGFpblBhcmFtZXRlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlc2lyZWRDaGFpbklkT3JDaGFpblBhcmFtZXRlcnMuY2hhaW5JZDtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIG5vIGRlc2lyZWQgY2hhaW4sIG9yIGl0J3MgZXF1YWwgdG8gdGhlIHJlY2VpdmVkLCB1cGRhdGVcbiAgICAgICAgICAgICAgICBpZiAoIWRlc2lyZWRDaGFpbklkIHx8IHJlY2VpdmVkQ2hhaW5JZCA9PT0gZGVzaXJlZENoYWluSWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGlvbnMudXBkYXRlKHsgY2hhaW5JZDogcmVjZWl2ZWRDaGFpbklkLCBhY2NvdW50cyB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNpcmVkQ2hhaW5JZEhleCA9IGAweCR7ZGVzaXJlZENoYWluSWQudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgaGVyZSwgd2UgY2FuIHRyeSB0byBzd2l0Y2ggbmV0d29ya3NcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlclxuICAgICAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbeyBjaGFpbklkOiBkZXNpcmVkQ2hhaW5JZEhleCB9XSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9tZXRhbWFzay1tb2JpbGUvaXNzdWVzLzMzMTIjaXNzdWVjb21tZW50LTEwNjU5MjMyOTRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gKChfYiA9IChfYSA9IGVycm9yLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcmlnaW5hbEVycm9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29kZSkgfHwgZXJyb3IuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gNDkwMiBpbmRpY2F0ZXMgdGhhdCB0aGUgY2hhaW4gaGFzIG5vdCBiZWVuIGFkZGVkIHRvIE1ldGFNYXNrIGFuZCB3YWxsZXRfYWRkRXRoZXJldW1DaGFpbiBuZWVkcyB0byBiZSBjYWxsZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLm1ldGFtYXNrLmlvL2d1aWRlL3JwYy1hcGkuaHRtbCN3YWxsZXQtc3dpdGNoZXRoZXJldW1jaGFpblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDb2RlID09PSA0OTAyICYmIHR5cGVvZiBkZXNpcmVkQ2hhaW5JZE9yQ2hhaW5QYXJhbWV0ZXJzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJvdmlkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGhlcmUsIHdlIGNhbiB0cnkgdG8gYWRkIGEgbmV3IG5ldHdvcmtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9hZGRFdGhlcmV1bUNoYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlc2lyZWRDaGFpbklkT3JDaGFpblBhcmFtZXRlcnMpLCB7IGNoYWluSWQ6IGRlc2lyZWRDaGFpbklkSGV4IH0pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuYWN0aXZhdGUoZGVzaXJlZENoYWluSWQpKTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBjYW5jZWxBY3RpdmF0aW9uID09PSBudWxsIHx8IGNhbmNlbEFjdGl2YXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbmNlbEFjdGl2YXRpb24oKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2F0Y2hBc3NldCh7IGFkZHJlc3MsIHN5bWJvbCwgZGVjaW1hbHMsIGltYWdlIH0pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm92aWRlcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHByb3ZpZGVyJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlclxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfd2F0Y2hBc3NldCcsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdFUkMyMCcsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNpbWFscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLCAvLyBBIHN0cmluZyB1cmwgb2YgdGhlIHRva2VuIGxvZ29cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoc3VjY2VzcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc3VjY2VzcylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWplY3RlZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTWV0YU1hc2sgPSBNZXRhTWFzaztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-react/metamask/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@web3-react/network/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@web3-react/network/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Network = void 0;\nconst types_1 = __webpack_require__(/*! @web3-react/types */ \"(ssr)/./node_modules/@web3-react/types/dist/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@web3-react/network/dist/utils.js\");\nfunction isUrl(url) {\n    return typeof url === 'string' || ('url' in url && !('connection' in url));\n}\nclass Network extends types_1.Connector {\n    constructor({ actions, urlMap, defaultChainId = Number(Object.keys(urlMap)[0]), timeout = 5000, }) {\n        super(actions);\n        this.providerCache = {};\n        this.urlMap = Object.keys(urlMap).reduce((accumulator, chainId) => {\n            const urls = urlMap[Number(chainId)];\n            if (Array.isArray(urls)) {\n                accumulator[Number(chainId)] = urls;\n            }\n            else {\n                // this ternary just makes typescript happy, since it can't infer that the array has elements of the same type\n                accumulator[Number(chainId)] = isUrl(urls) ? [urls] : [urls];\n            }\n            return accumulator;\n        }, {});\n        this.defaultChainId = defaultChainId;\n        this.timeout = timeout;\n    }\n    isomorphicInitialize(chainId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if (this.providerCache[chainId])\n                return this.providerCache[chainId];\n            const urls = this.urlMap[chainId];\n            // early return if we have a single jsonrpc provider already\n            if (urls.length === 1 && !isUrl(urls[0])) {\n                return (this.providerCache[chainId] = Promise.resolve(urls[0]));\n            }\n            return (this.providerCache[chainId] = Promise.resolve().then(() => __importStar(__webpack_require__(/*! @ethersproject/providers */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/index.js\"))).then(({ JsonRpcProvider }) => {\n                const providers = urls.map((url) => (isUrl(url) ? new JsonRpcProvider(url, chainId) : url));\n                return (0, utils_1.getBestProvider)(providers, this.timeout);\n            }));\n        });\n    }\n    /**\n     * Initiates a connection.\n     *\n     * @param desiredChainId - The desired chain to connect to.\n     */\n    activate(desiredChainId = this.defaultChainId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let cancelActivation;\n            if (!this.providerCache[desiredChainId]) {\n                cancelActivation = this.actions.startActivation();\n            }\n            return this.isomorphicInitialize(desiredChainId)\n                .then((customProvider) => __awaiter(this, void 0, void 0, function* () {\n                this.customProvider = customProvider;\n                const { chainId } = yield this.customProvider.getNetwork();\n                this.actions.update({ chainId, accounts: [] });\n            }))\n                .catch((error) => {\n                cancelActivation === null || cancelActivation === void 0 ? void 0 : cancelActivation();\n                throw error;\n            });\n        });\n    }\n}\nexports.Network = Network;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3QvbmV0d29yay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFtQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyx1RUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtRkFBbUY7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsbUJBQU8sQ0FBQyxnR0FBMEIsWUFBWSxpQkFBaUI7QUFDM0o7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEMsc0NBQXNDLHVCQUF1QjtBQUM3RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3dhbGxldC1jb25uZWN0aW9ucy8uL25vZGVfbW9kdWxlcy9Ad2ViMy1yZWFjdC9uZXR3b3JrL2Rpc3QvaW5kZXguanM/Mzg3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5ldHdvcmsgPSB2b2lkIDA7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIkB3ZWIzLXJlYWN0L3R5cGVzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gaXNVcmwodXJsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnIHx8ICgndXJsJyBpbiB1cmwgJiYgISgnY29ubmVjdGlvbicgaW4gdXJsKSk7XG59XG5jbGFzcyBOZXR3b3JrIGV4dGVuZHMgdHlwZXNfMS5Db25uZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgYWN0aW9ucywgdXJsTWFwLCBkZWZhdWx0Q2hhaW5JZCA9IE51bWJlcihPYmplY3Qua2V5cyh1cmxNYXApWzBdKSwgdGltZW91dCA9IDUwMDAsIH0pIHtcbiAgICAgICAgc3VwZXIoYWN0aW9ucyk7XG4gICAgICAgIHRoaXMucHJvdmlkZXJDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLnVybE1hcCA9IE9iamVjdC5rZXlzKHVybE1hcCkucmVkdWNlKChhY2N1bXVsYXRvciwgY2hhaW5JZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXJscyA9IHVybE1hcFtOdW1iZXIoY2hhaW5JZCldO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXJscykpIHtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRvcltOdW1iZXIoY2hhaW5JZCldID0gdXJscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgdGVybmFyeSBqdXN0IG1ha2VzIHR5cGVzY3JpcHQgaGFwcHksIHNpbmNlIGl0IGNhbid0IGluZmVyIHRoYXQgdGhlIGFycmF5IGhhcyBlbGVtZW50cyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAgICAgICAgICAgYWNjdW11bGF0b3JbTnVtYmVyKGNoYWluSWQpXSA9IGlzVXJsKHVybHMpID8gW3VybHNdIDogW3VybHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHRoaXMuZGVmYXVsdENoYWluSWQgPSBkZWZhdWx0Q2hhaW5JZDtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG4gICAgaXNvbW9ycGhpY0luaXRpYWxpemUoY2hhaW5JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLnByb3ZpZGVyQ2FjaGVbY2hhaW5JZF0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXJDYWNoZVtjaGFpbklkXTtcbiAgICAgICAgICAgIGNvbnN0IHVybHMgPSB0aGlzLnVybE1hcFtjaGFpbklkXTtcbiAgICAgICAgICAgIC8vIGVhcmx5IHJldHVybiBpZiB3ZSBoYXZlIGEgc2luZ2xlIGpzb25ycGMgcHJvdmlkZXIgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKHVybHMubGVuZ3RoID09PSAxICYmICFpc1VybCh1cmxzWzBdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5wcm92aWRlckNhY2hlW2NoYWluSWRdID0gUHJvbWlzZS5yZXNvbHZlKHVybHNbMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAodGhpcy5wcm92aWRlckNhY2hlW2NoYWluSWRdID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBfX2ltcG9ydFN0YXIocmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzJykpKS50aGVuKCh7IEpzb25ScGNQcm92aWRlciB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXJzID0gdXJscy5tYXAoKHVybCkgPT4gKGlzVXJsKHVybCkgPyBuZXcgSnNvblJwY1Byb3ZpZGVyKHVybCwgY2hhaW5JZCkgOiB1cmwpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuZ2V0QmVzdFByb3ZpZGVyKShwcm92aWRlcnMsIHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZXMgYSBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRlc2lyZWRDaGFpbklkIC0gVGhlIGRlc2lyZWQgY2hhaW4gdG8gY29ubmVjdCB0by5cbiAgICAgKi9cbiAgICBhY3RpdmF0ZShkZXNpcmVkQ2hhaW5JZCA9IHRoaXMuZGVmYXVsdENoYWluSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBjYW5jZWxBY3RpdmF0aW9uO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyQ2FjaGVbZGVzaXJlZENoYWluSWRdKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsQWN0aXZhdGlvbiA9IHRoaXMuYWN0aW9ucy5zdGFydEFjdGl2YXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzb21vcnBoaWNJbml0aWFsaXplKGRlc2lyZWRDaGFpbklkKVxuICAgICAgICAgICAgICAgIC50aGVuKChjdXN0b21Qcm92aWRlcikgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tUHJvdmlkZXIgPSBjdXN0b21Qcm92aWRlcjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHlpZWxkIHRoaXMuY3VzdG9tUHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy51cGRhdGUoeyBjaGFpbklkLCBhY2NvdW50czogW10gfSk7XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FuY2VsQWN0aXZhdGlvbiA9PT0gbnVsbCB8fCBjYW5jZWxBY3RpdmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYW5jZWxBY3RpdmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5OZXR3b3JrID0gTmV0d29yaztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-react/network/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@web3-react/network/dist/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/@web3-react/network/dist/utils.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getBestProvider = void 0;\n/**\n * @param providers - An array of providers to try to connect to.\n * @param timeout - How long to wait before a call is considered failed, in ms.\n */\nfunction getBestProvider(providers, timeout = 5000) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // if we only have 1 provider, it's the best!\n        if (providers.length === 1)\n            return providers[0];\n        // the below returns the first provider for which there's been a successful call, prioritized by index\n        return new Promise((resolve) => {\n            let resolved = false;\n            const successes = {};\n            providers.forEach((provider, i) => {\n                // create a promise that resolves on a successful call, and rejects on a failed call or after timeout milliseconds\n                const promise = new Promise((resolve, reject) => {\n                    provider\n                        .getNetwork()\n                        .then(() => resolve())\n                        .catch(() => reject());\n                    // set a timeout to reject\n                    setTimeout(() => {\n                        reject();\n                    }, timeout);\n                });\n                void promise\n                    .then(() => true)\n                    .catch(() => false)\n                    .then((success) => {\n                    // if we already resolved, return\n                    if (resolved)\n                        return;\n                    // store the result of the call\n                    successes[i] = success;\n                    // if this is the last call and we haven't resolved yet - do so\n                    if (Object.keys(successes).length === providers.length) {\n                        const index = Object.keys(successes).findIndex((j) => successes[Number(j)]);\n                        // no need to set resolved to true, as this is the last promise\n                        return resolve(providers[index === -1 ? 0 : index]);\n                    }\n                    // otherwise, for each prospective index, check if we can resolve\n                    new Array(providers.length).fill(0).forEach((_, prospectiveIndex) => {\n                        // to resolve, we need to:\n                        // a) have successfully made a call\n                        // b) not be waiting on any other higher-index calls\n                        if (successes[prospectiveIndex] &&\n                            new Array(prospectiveIndex).fill(0).every((_, j) => successes[j] === false)) {\n                            resolved = true;\n                            resolve(providers[prospectiveIndex]);\n                        }\n                    });\n                });\n            });\n        });\n    });\n}\nexports.getBestProvider = getBestProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3QvbmV0d29yay9kaXN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FsbGV0LWNvbm5lY3Rpb25zLy4vbm9kZV9tb2R1bGVzL0B3ZWIzLXJlYWN0L25ldHdvcmsvZGlzdC91dGlscy5qcz8xM2FiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEJlc3RQcm92aWRlciA9IHZvaWQgMDtcbi8qKlxuICogQHBhcmFtIHByb3ZpZGVycyAtIEFuIGFycmF5IG9mIHByb3ZpZGVycyB0byB0cnkgdG8gY29ubmVjdCB0by5cbiAqIEBwYXJhbSB0aW1lb3V0IC0gSG93IGxvbmcgdG8gd2FpdCBiZWZvcmUgYSBjYWxsIGlzIGNvbnNpZGVyZWQgZmFpbGVkLCBpbiBtcy5cbiAqL1xuZnVuY3Rpb24gZ2V0QmVzdFByb3ZpZGVyKHByb3ZpZGVycywgdGltZW91dCA9IDUwMDApIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAvLyBpZiB3ZSBvbmx5IGhhdmUgMSBwcm92aWRlciwgaXQncyB0aGUgYmVzdCFcbiAgICAgICAgaWYgKHByb3ZpZGVycy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJzWzBdO1xuICAgICAgICAvLyB0aGUgYmVsb3cgcmV0dXJucyB0aGUgZmlyc3QgcHJvdmlkZXIgZm9yIHdoaWNoIHRoZXJlJ3MgYmVlbiBhIHN1Y2Nlc3NmdWwgY2FsbCwgcHJpb3JpdGl6ZWQgYnkgaW5kZXhcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IHt9O1xuICAgICAgICAgICAgcHJvdmlkZXJzLmZvckVhY2goKHByb3ZpZGVyLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uIGEgc3VjY2Vzc2Z1bCBjYWxsLCBhbmQgcmVqZWN0cyBvbiBhIGZhaWxlZCBjYWxsIG9yIGFmdGVyIHRpbWVvdXQgbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXROZXR3b3JrKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHJlc29sdmUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiByZWplY3QoKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBhIHRpbWVvdXQgdG8gcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZvaWQgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChzdWNjZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFscmVhZHkgcmVzb2x2ZWQsIHJldHVyblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2VzW2ldID0gc3VjY2VzcztcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCBjYWxsIGFuZCB3ZSBoYXZlbid0IHJlc29sdmVkIHlldCAtIGRvIHNvXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzdWNjZXNzZXMpLmxlbmd0aCA9PT0gcHJvdmlkZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBPYmplY3Qua2V5cyhzdWNjZXNzZXMpLmZpbmRJbmRleCgoaikgPT4gc3VjY2Vzc2VzW051bWJlcihqKV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBzZXQgcmVzb2x2ZWQgdG8gdHJ1ZSwgYXMgdGhpcyBpcyB0aGUgbGFzdCBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShwcm92aWRlcnNbaW5kZXggPT09IC0xID8gMCA6IGluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBmb3IgZWFjaCBwcm9zcGVjdGl2ZSBpbmRleCwgY2hlY2sgaWYgd2UgY2FuIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgbmV3IEFycmF5KHByb3ZpZGVycy5sZW5ndGgpLmZpbGwoMCkuZm9yRWFjaCgoXywgcHJvc3BlY3RpdmVJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gcmVzb2x2ZSwgd2UgbmVlZCB0bzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEpIGhhdmUgc3VjY2Vzc2Z1bGx5IG1hZGUgYSBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiKSBub3QgYmUgd2FpdGluZyBvbiBhbnkgb3RoZXIgaGlnaGVyLWluZGV4IGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc2VzW3Byb3NwZWN0aXZlSW5kZXhdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEFycmF5KHByb3NwZWN0aXZlSW5kZXgpLmZpbGwoMCkuZXZlcnkoKF8sIGopID0+IHN1Y2Nlc3Nlc1tqXSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocHJvdmlkZXJzW3Byb3NwZWN0aXZlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmdldEJlc3RQcm92aWRlciA9IGdldEJlc3RQcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-react/network/dist/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@web3-react/store/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@web3-react/store/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createWeb3ReactStoreAndActions = exports.MAX_SAFE_CHAIN_ID = void 0;\nconst address_1 = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/@ethersproject/address/lib.esm/index.js\");\nconst zustand_1 = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/zustand/esm/index.js\");\n/**\n * MAX_SAFE_CHAIN_ID is the upper bound limit on what will be accepted for `chainId`\n * `MAX_SAFE_CHAIN_ID = floor( ( 2**53 - 39 ) / 2 ) = 4503599627370476`\n *\n * @see {@link https://github.com/MetaMask/metamask-extension/blob/b6673731e2367e119a5fee9a454dd40bd4968948/shared/constants/network.js#L31}\n */\nexports.MAX_SAFE_CHAIN_ID = 4503599627370476;\nfunction validateChainId(chainId) {\n    if (!Number.isInteger(chainId) || chainId <= 0 || chainId > exports.MAX_SAFE_CHAIN_ID) {\n        throw new Error(`Invalid chainId ${chainId}`);\n    }\n}\nfunction validateAccount(account) {\n    return (0, address_1.getAddress)(account);\n}\nconst DEFAULT_STATE = {\n    chainId: undefined,\n    accounts: undefined,\n    activating: false,\n};\nfunction createWeb3ReactStoreAndActions() {\n    const store = (0, zustand_1.createStore)()(() => DEFAULT_STATE);\n    // flag for tracking updates so we don't clobber data when cancelling activation\n    let nullifier = 0;\n    /**\n     * Sets activating to true, indicating that an update is in progress.\n     *\n     * @returns cancelActivation - A function that cancels the activation by setting activating to false,\n     * as long as there haven't been any intervening updates.\n     */\n    function startActivation() {\n        const nullifierCached = ++nullifier;\n        store.setState(Object.assign(Object.assign({}, DEFAULT_STATE), { activating: true }));\n        // return a function that cancels the activation iff nothing else has happened\n        return () => {\n            if (nullifier === nullifierCached)\n                store.setState({ activating: false });\n        };\n    }\n    /**\n     * Used to report a `stateUpdate` which is merged with existing state. The first `stateUpdate` that results in chainId\n     * and accounts being set will also set activating to false, indicating a successful connection.\n     *\n     * @param stateUpdate - The state update to report.\n     */\n    function update(stateUpdate) {\n        // validate chainId statically, independent of existing state\n        if (stateUpdate.chainId !== undefined) {\n            validateChainId(stateUpdate.chainId);\n        }\n        // validate accounts statically, independent of existing state\n        if (stateUpdate.accounts !== undefined) {\n            for (let i = 0; i < stateUpdate.accounts.length; i++) {\n                stateUpdate.accounts[i] = validateAccount(stateUpdate.accounts[i]);\n            }\n        }\n        nullifier++;\n        store.setState((existingState) => {\n            var _a, _b;\n            // determine the next chainId and accounts\n            const chainId = (_a = stateUpdate.chainId) !== null && _a !== void 0 ? _a : existingState.chainId;\n            const accounts = (_b = stateUpdate.accounts) !== null && _b !== void 0 ? _b : existingState.accounts;\n            // ensure that the activating flag is cleared when appropriate\n            let activating = existingState.activating;\n            if (activating && chainId && accounts) {\n                activating = false;\n            }\n            return { chainId, accounts, activating };\n        });\n    }\n    /**\n     * Resets connector state back to the default state.\n     */\n    function resetState() {\n        nullifier++;\n        store.setState(DEFAULT_STATE);\n    }\n    return [store, { startActivation, update, resetState }];\n}\nexports.createWeb3ReactStoreAndActions = createWeb3ReactStoreAndActions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3Qvc3RvcmUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0MsR0FBRyx5QkFBeUI7QUFDbEUsa0JBQWtCLG1CQUFPLENBQUMsNEZBQXdCO0FBQ2xELGtCQUFrQixtQkFBTyxDQUFDLDBEQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxvQkFBb0Isa0JBQWtCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dhbGxldC1jb25uZWN0aW9ucy8uL25vZGVfbW9kdWxlcy9Ad2ViMy1yZWFjdC9zdG9yZS9kaXN0L2luZGV4LmpzP2RjZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVdlYjNSZWFjdFN0b3JlQW5kQWN0aW9ucyA9IGV4cG9ydHMuTUFYX1NBRkVfQ0hBSU5fSUQgPSB2b2lkIDA7XG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiKTtcbmNvbnN0IHp1c3RhbmRfMSA9IHJlcXVpcmUoXCJ6dXN0YW5kXCIpO1xuLyoqXG4gKiBNQVhfU0FGRV9DSEFJTl9JRCBpcyB0aGUgdXBwZXIgYm91bmQgbGltaXQgb24gd2hhdCB3aWxsIGJlIGFjY2VwdGVkIGZvciBgY2hhaW5JZGBcbiAqIGBNQVhfU0FGRV9DSEFJTl9JRCA9IGZsb29yKCAoIDIqKjUzIC0gMzkgKSAvIDIgKSA9IDQ1MDM1OTk2MjczNzA0NzZgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL21ldGFtYXNrLWV4dGVuc2lvbi9ibG9iL2I2NjczNzMxZTIzNjdlMTE5YTVmZWU5YTQ1NGRkNDBiZDQ5Njg5NDgvc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrLmpzI0wzMX1cbiAqL1xuZXhwb3J0cy5NQVhfU0FGRV9DSEFJTl9JRCA9IDQ1MDM1OTk2MjczNzA0NzY7XG5mdW5jdGlvbiB2YWxpZGF0ZUNoYWluSWQoY2hhaW5JZCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjaGFpbklkKSB8fCBjaGFpbklkIDw9IDAgfHwgY2hhaW5JZCA+IGV4cG9ydHMuTUFYX1NBRkVfQ0hBSU5fSUQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYWluSWQgJHtjaGFpbklkfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQWNjb3VudChhY2NvdW50KSB7XG4gICAgcmV0dXJuICgwLCBhZGRyZXNzXzEuZ2V0QWRkcmVzcykoYWNjb3VudCk7XG59XG5jb25zdCBERUZBVUxUX1NUQVRFID0ge1xuICAgIGNoYWluSWQ6IHVuZGVmaW5lZCxcbiAgICBhY2NvdW50czogdW5kZWZpbmVkLFxuICAgIGFjdGl2YXRpbmc6IGZhbHNlLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZVdlYjNSZWFjdFN0b3JlQW5kQWN0aW9ucygpIHtcbiAgICBjb25zdCBzdG9yZSA9ICgwLCB6dXN0YW5kXzEuY3JlYXRlU3RvcmUpKCkoKCkgPT4gREVGQVVMVF9TVEFURSk7XG4gICAgLy8gZmxhZyBmb3IgdHJhY2tpbmcgdXBkYXRlcyBzbyB3ZSBkb24ndCBjbG9iYmVyIGRhdGEgd2hlbiBjYW5jZWxsaW5nIGFjdGl2YXRpb25cbiAgICBsZXQgbnVsbGlmaWVyID0gMDtcbiAgICAvKipcbiAgICAgKiBTZXRzIGFjdGl2YXRpbmcgdG8gdHJ1ZSwgaW5kaWNhdGluZyB0aGF0IGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGNhbmNlbEFjdGl2YXRpb24gLSBBIGZ1bmN0aW9uIHRoYXQgY2FuY2VscyB0aGUgYWN0aXZhdGlvbiBieSBzZXR0aW5nIGFjdGl2YXRpbmcgdG8gZmFsc2UsXG4gICAgICogYXMgbG9uZyBhcyB0aGVyZSBoYXZlbid0IGJlZW4gYW55IGludGVydmVuaW5nIHVwZGF0ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRBY3RpdmF0aW9uKCkge1xuICAgICAgICBjb25zdCBudWxsaWZpZXJDYWNoZWQgPSArK251bGxpZmllcjtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NUQVRFKSwgeyBhY3RpdmF0aW5nOiB0cnVlIH0pKTtcbiAgICAgICAgLy8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW5jZWxzIHRoZSBhY3RpdmF0aW9uIGlmZiBub3RoaW5nIGVsc2UgaGFzIGhhcHBlbmVkXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAobnVsbGlmaWVyID09PSBudWxsaWZpZXJDYWNoZWQpXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBhY3RpdmF0aW5nOiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZXBvcnQgYSBgc3RhdGVVcGRhdGVgIHdoaWNoIGlzIG1lcmdlZCB3aXRoIGV4aXN0aW5nIHN0YXRlLiBUaGUgZmlyc3QgYHN0YXRlVXBkYXRlYCB0aGF0IHJlc3VsdHMgaW4gY2hhaW5JZFxuICAgICAqIGFuZCBhY2NvdW50cyBiZWluZyBzZXQgd2lsbCBhbHNvIHNldCBhY3RpdmF0aW5nIHRvIGZhbHNlLCBpbmRpY2F0aW5nIGEgc3VjY2Vzc2Z1bCBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlVXBkYXRlIC0gVGhlIHN0YXRlIHVwZGF0ZSB0byByZXBvcnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlKHN0YXRlVXBkYXRlKSB7XG4gICAgICAgIC8vIHZhbGlkYXRlIGNoYWluSWQgc3RhdGljYWxseSwgaW5kZXBlbmRlbnQgb2YgZXhpc3Rpbmcgc3RhdGVcbiAgICAgICAgaWYgKHN0YXRlVXBkYXRlLmNoYWluSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsaWRhdGVDaGFpbklkKHN0YXRlVXBkYXRlLmNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhbGlkYXRlIGFjY291bnRzIHN0YXRpY2FsbHksIGluZGVwZW5kZW50IG9mIGV4aXN0aW5nIHN0YXRlXG4gICAgICAgIGlmIChzdGF0ZVVwZGF0ZS5hY2NvdW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlVXBkYXRlLmFjY291bnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVVcGRhdGUuYWNjb3VudHNbaV0gPSB2YWxpZGF0ZUFjY291bnQoc3RhdGVVcGRhdGUuYWNjb3VudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bGxpZmllcisrO1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSgoZXhpc3RpbmdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgbmV4dCBjaGFpbklkIGFuZCBhY2NvdW50c1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IChfYSA9IHN0YXRlVXBkYXRlLmNoYWluSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4aXN0aW5nU3RhdGUuY2hhaW5JZDtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gKF9iID0gc3RhdGVVcGRhdGUuYWNjb3VudHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGV4aXN0aW5nU3RhdGUuYWNjb3VudHM7XG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgYWN0aXZhdGluZyBmbGFnIGlzIGNsZWFyZWQgd2hlbiBhcHByb3ByaWF0ZVxuICAgICAgICAgICAgbGV0IGFjdGl2YXRpbmcgPSBleGlzdGluZ1N0YXRlLmFjdGl2YXRpbmc7XG4gICAgICAgICAgICBpZiAoYWN0aXZhdGluZyAmJiBjaGFpbklkICYmIGFjY291bnRzKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhaW5JZCwgYWNjb3VudHMsIGFjdGl2YXRpbmcgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBjb25uZWN0b3Igc3RhdGUgYmFjayB0byB0aGUgZGVmYXVsdCBzdGF0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNldFN0YXRlKCkge1xuICAgICAgICBudWxsaWZpZXIrKztcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoREVGQVVMVF9TVEFURSk7XG4gICAgfVxuICAgIHJldHVybiBbc3RvcmUsIHsgc3RhcnRBY3RpdmF0aW9uLCB1cGRhdGUsIHJlc2V0U3RhdGUgfV07XG59XG5leHBvcnRzLmNyZWF0ZVdlYjNSZWFjdFN0b3JlQW5kQWN0aW9ucyA9IGNyZWF0ZVdlYjNSZWFjdFN0b3JlQW5kQWN0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-react/store/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@web3-react/types/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@web3-react/types/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Connector = void 0;\nclass Connector {\n    /**\n     * @param actions - Methods bound to a zustand store that tracks the state of the connector.\n     * @param onError - An optional handler which will report errors thrown from event listeners.\n     * Actions are used by the connector to report changes in connection status.\n     */\n    constructor(actions, onError) {\n        this.actions = actions;\n        this.onError = onError;\n    }\n    /**\n     * Reset the state of the connector without otherwise interacting with the connection.\n     */\n    resetState() {\n        this.actions.resetState();\n    }\n}\nexports.Connector = Connector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3QvdHlwZXMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dhbGxldC1jb25uZWN0aW9ucy8uL25vZGVfbW9kdWxlcy9Ad2ViMy1yZWFjdC90eXBlcy9kaXN0L2luZGV4LmpzPzcxNjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbm5lY3RvciA9IHZvaWQgMDtcbmNsYXNzIENvbm5lY3RvciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFjdGlvbnMgLSBNZXRob2RzIGJvdW5kIHRvIGEgenVzdGFuZCBzdG9yZSB0aGF0IHRyYWNrcyB0aGUgc3RhdGUgb2YgdGhlIGNvbm5lY3Rvci5cbiAgICAgKiBAcGFyYW0gb25FcnJvciAtIEFuIG9wdGlvbmFsIGhhbmRsZXIgd2hpY2ggd2lsbCByZXBvcnQgZXJyb3JzIHRocm93biBmcm9tIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBBY3Rpb25zIGFyZSB1c2VkIGJ5IHRoZSBjb25uZWN0b3IgdG8gcmVwb3J0IGNoYW5nZXMgaW4gY29ubmVjdGlvbiBzdGF0dXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWN0aW9ucywgb25FcnJvcikge1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBhY3Rpb25zO1xuICAgICAgICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgc3RhdGUgb2YgdGhlIGNvbm5lY3RvciB3aXRob3V0IG90aGVyd2lzZSBpbnRlcmFjdGluZyB3aXRoIHRoZSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIHJlc2V0U3RhdGUoKSB7XG4gICAgICAgIHRoaXMuYWN0aW9ucy5yZXNldFN0YXRlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Db25uZWN0b3IgPSBDb25uZWN0b3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-react/types/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@web3-react/walletconnect-v2/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@web3-react/walletconnect-v2/dist/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletConnect = exports.URI_AVAILABLE = void 0;\nconst types_1 = __webpack_require__(/*! @web3-react/types */ \"(ssr)/./node_modules/@web3-react/types/dist/index.js\");\nconst eventemitter3_1 = __importDefault(__webpack_require__(/*! eventemitter3 */ \"(ssr)/./node_modules/eventemitter3/index.js\"));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@web3-react/walletconnect-v2/dist/utils.js\");\nexports.URI_AVAILABLE = 'URI_AVAILABLE';\nconst DEFAULT_TIMEOUT = 5000;\nclass WalletConnect extends types_1.Connector {\n    constructor({ actions, defaultChainId, options, timeout = DEFAULT_TIMEOUT, onError }) {\n        super(actions, onError);\n        this.events = new eventemitter3_1.default();\n        this.disconnectListener = (error) => {\n            var _a;\n            this.actions.resetState();\n            if (error)\n                (_a = this.onError) === null || _a === void 0 ? void 0 : _a.call(this, error);\n        };\n        this.chainChangedListener = (chainId) => {\n            this.actions.update({ chainId: Number.parseInt(chainId, 16) });\n        };\n        this.accountsChangedListener = (accounts) => {\n            this.actions.update({ accounts });\n        };\n        this.URIListener = (uri) => {\n            this.events.emit(exports.URI_AVAILABLE, uri);\n        };\n        const { rpcMap, rpc } = options, rest = __rest(options, [\"rpcMap\", \"rpc\"]);\n        this.options = rest;\n        this.defaultChainId = defaultChainId;\n        this.rpcMap = rpcMap || rpc;\n        this.timeout = timeout;\n        const { chains, optionalChains } = this.getChainProps(rest.chains, rest.optionalChains, defaultChainId);\n        this.chains = chains;\n        this.optionalChains = optionalChains;\n    }\n    initializeProvider(desiredChainId = this.defaultChainId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const rpcMap = this.rpcMap ? (0, utils_1.getBestUrlMap)(this.rpcMap, this.timeout) : undefined;\n            const chainProps = this.getChainProps(this.chains, this.optionalChains, desiredChainId);\n            const ethProviderModule = yield Promise.resolve().then(() => __importStar(__webpack_require__(/*! @walletconnect/ethereum-provider */ \"(ssr)/./node_modules/@walletconnect/ethereum-provider/dist/index.es.js\")));\n            this.provider = yield ethProviderModule.default.init(Object.assign(Object.assign(Object.assign({}, this.options), chainProps), { rpcMap: yield rpcMap }));\n            return this.provider\n                .on('disconnect', this.disconnectListener)\n                .on('chainChanged', this.chainChangedListener)\n                .on('accountsChanged', this.accountsChangedListener)\n                .on('display_uri', this.URIListener);\n        });\n    }\n    getChainProps(chains, optionalChains, desiredChainId = this.defaultChainId) {\n        // Reorder chains and optionalChains if necessary\n        const orderedChains = (0, utils_1.getChainsWithDefault)(chains, desiredChainId);\n        const orderedOptionalChains = (0, utils_1.getChainsWithDefault)(optionalChains, desiredChainId);\n        // Validate and return the result.\n        // Type discrimination requires that we use these typeguard checks to guarantee a valid return type.\n        if ((0, utils_1.isArrayOneOrMore)(orderedChains)) {\n            return { chains: orderedChains, optionalChains: orderedOptionalChains };\n        }\n        else if ((0, utils_1.isArrayOneOrMore)(orderedOptionalChains)) {\n            return { chains: orderedChains, optionalChains: orderedOptionalChains };\n        }\n        throw new Error('Either chains or optionalChains must have at least one item.');\n    }\n    isomorphicInitialize(desiredChainId = this.defaultChainId) {\n        if (this.eagerConnection)\n            return this.eagerConnection;\n        return (this.eagerConnection = this.initializeProvider(desiredChainId));\n    }\n    /** {@inheritdoc Connector.connectEagerly} */\n    connectEagerly() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cancelActivation = this.actions.startActivation();\n            try {\n                const provider = yield this.isomorphicInitialize();\n                // WalletConnect automatically persists and restores active sessions\n                if (!provider.session) {\n                    throw new Error('No active session found. Connect your wallet first.');\n                }\n                this.actions.update({ accounts: provider.accounts, chainId: provider.chainId });\n            }\n            catch (error) {\n                yield this.deactivate();\n                cancelActivation();\n                throw error;\n            }\n        });\n    }\n    /**\n     * @param desiredChainId - The desired chainId to connect to.\n     */\n    activate(desiredChainId) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const provider = yield this.isomorphicInitialize(desiredChainId);\n            if (provider.session) {\n                if (!desiredChainId || desiredChainId === provider.chainId)\n                    return;\n                // WalletConnect exposes connected accounts, not chains: `eip155:${chainId}:${address}`\n                const isConnectedToDesiredChain = provider.session.namespaces.eip155.accounts.some((account) => account.startsWith(`eip155:${desiredChainId}:`));\n                if (!isConnectedToDesiredChain) {\n                    if ((_a = this.options.optionalChains) === null || _a === void 0 ? void 0 : _a.includes(desiredChainId)) {\n                        throw new Error(`Cannot activate an optional chain (${desiredChainId}), as the wallet is not connected to it.\\n\\tYou should handle this error in application code, as there is no guarantee that a wallet is connected to a chain configured in \"optionalChains\".`);\n                    }\n                    throw new Error(`Unknown chain (${desiredChainId}). Make sure to include any chains you might connect to in the \"chains\" or \"optionalChains\" parameters when initializing WalletConnect.`);\n                }\n                return provider.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: `0x${desiredChainId.toString(16)}` }],\n                });\n            }\n            const cancelActivation = this.actions.startActivation();\n            try {\n                yield provider.enable();\n                this.actions.update({ chainId: provider.chainId, accounts: provider.accounts });\n            }\n            catch (error) {\n                yield this.deactivate();\n                cancelActivation();\n                throw error;\n            }\n        });\n    }\n    /** {@inheritdoc Connector.deactivate} */\n    deactivate() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            (_a = this.provider) === null || _a === void 0 ? void 0 : _a.removeListener('disconnect', this.disconnectListener).removeListener('chainChanged', this.chainChangedListener).removeListener('accountsChanged', this.accountsChangedListener).removeListener('display_uri', this.URIListener).disconnect();\n            this.provider = undefined;\n            this.eagerConnection = undefined;\n            this.actions.resetState();\n        });\n    }\n}\nexports.WalletConnect = WalletConnect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3Qvd2FsbGV0Y29ubmVjdC12Mi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLHFCQUFxQjtBQUM3QyxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBbUI7QUFDM0Msd0NBQXdDLG1CQUFPLENBQUMsa0VBQWU7QUFDL0QsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQVM7QUFDakMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxrQkFBa0Isc0VBQXNFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1Q0FBdUM7QUFDekU7QUFDQTtBQUNBLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLG1CQUFPLENBQUMsZ0hBQWtDO0FBQ2hJLDZHQUE2RyxnQ0FBZ0Msc0JBQXNCO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNDQUFzQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0RBQXdEO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFFBQVEsR0FBRyxRQUFRO0FBQ3RHLDZJQUE2SSxlQUFlO0FBQzVKO0FBQ0E7QUFDQSw4RUFBOEUsZUFBZTtBQUM3RjtBQUNBLHNEQUFzRCxlQUFlO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjLDRCQUE0QixHQUFHO0FBQzVFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx3REFBd0Q7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUyxrQ0FBa0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dhbGxldC1jb25uZWN0aW9ucy8uL25vZGVfbW9kdWxlcy9Ad2ViMy1yZWFjdC93YWxsZXRjb25uZWN0LXYyL2Rpc3QvaW5kZXguanM/ZjI5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldhbGxldENvbm5lY3QgPSBleHBvcnRzLlVSSV9BVkFJTEFCTEUgPSB2b2lkIDA7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIkB3ZWIzLXJlYWN0L3R5cGVzXCIpO1xuY29uc3QgZXZlbnRlbWl0dGVyM18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJldmVudGVtaXR0ZXIzXCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMuVVJJX0FWQUlMQUJMRSA9ICdVUklfQVZBSUxBQkxFJztcbmNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDUwMDA7XG5jbGFzcyBXYWxsZXRDb25uZWN0IGV4dGVuZHMgdHlwZXNfMS5Db25uZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgYWN0aW9ucywgZGVmYXVsdENoYWluSWQsIG9wdGlvbnMsIHRpbWVvdXQgPSBERUZBVUxUX1RJTUVPVVQsIG9uRXJyb3IgfSkge1xuICAgICAgICBzdXBlcihhY3Rpb25zLCBvbkVycm9yKTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgZXZlbnRlbWl0dGVyM18xLmRlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXIgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5vbkVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhaW5DaGFuZ2VkTGlzdGVuZXIgPSAoY2hhaW5JZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnVwZGF0ZSh7IGNoYWluSWQ6IE51bWJlci5wYXJzZUludChjaGFpbklkLCAxNikgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWNjb3VudHNDaGFuZ2VkTGlzdGVuZXIgPSAoYWNjb3VudHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy51cGRhdGUoeyBhY2NvdW50cyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5VUklMaXN0ZW5lciA9ICh1cmkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoZXhwb3J0cy5VUklfQVZBSUxBQkxFLCB1cmkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IHJwY01hcCwgcnBjIH0gPSBvcHRpb25zLCByZXN0ID0gX19yZXN0KG9wdGlvbnMsIFtcInJwY01hcFwiLCBcInJwY1wiXSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHJlc3Q7XG4gICAgICAgIHRoaXMuZGVmYXVsdENoYWluSWQgPSBkZWZhdWx0Q2hhaW5JZDtcbiAgICAgICAgdGhpcy5ycGNNYXAgPSBycGNNYXAgfHwgcnBjO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICBjb25zdCB7IGNoYWlucywgb3B0aW9uYWxDaGFpbnMgfSA9IHRoaXMuZ2V0Q2hhaW5Qcm9wcyhyZXN0LmNoYWlucywgcmVzdC5vcHRpb25hbENoYWlucywgZGVmYXVsdENoYWluSWQpO1xuICAgICAgICB0aGlzLmNoYWlucyA9IGNoYWlucztcbiAgICAgICAgdGhpcy5vcHRpb25hbENoYWlucyA9IG9wdGlvbmFsQ2hhaW5zO1xuICAgIH1cbiAgICBpbml0aWFsaXplUHJvdmlkZXIoZGVzaXJlZENoYWluSWQgPSB0aGlzLmRlZmF1bHRDaGFpbklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBycGNNYXAgPSB0aGlzLnJwY01hcCA/ICgwLCB1dGlsc18xLmdldEJlc3RVcmxNYXApKHRoaXMucnBjTWFwLCB0aGlzLnRpbWVvdXQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgY2hhaW5Qcm9wcyA9IHRoaXMuZ2V0Q2hhaW5Qcm9wcyh0aGlzLmNoYWlucywgdGhpcy5vcHRpb25hbENoYWlucywgZGVzaXJlZENoYWluSWQpO1xuICAgICAgICAgICAgY29uc3QgZXRoUHJvdmlkZXJNb2R1bGUgPSB5aWVsZCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IF9faW1wb3J0U3RhcihyZXF1aXJlKCdAd2FsbGV0Y29ubmVjdC9ldGhlcmV1bS1wcm92aWRlcicpKSk7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyID0geWllbGQgZXRoUHJvdmlkZXJNb2R1bGUuZGVmYXVsdC5pbml0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCBjaGFpblByb3BzKSwgeyBycGNNYXA6IHlpZWxkIHJwY01hcCB9KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlclxuICAgICAgICAgICAgICAgIC5vbignZGlzY29ubmVjdCcsIHRoaXMuZGlzY29ubmVjdExpc3RlbmVyKVxuICAgICAgICAgICAgICAgIC5vbignY2hhaW5DaGFuZ2VkJywgdGhpcy5jaGFpbkNoYW5nZWRMaXN0ZW5lcilcbiAgICAgICAgICAgICAgICAub24oJ2FjY291bnRzQ2hhbmdlZCcsIHRoaXMuYWNjb3VudHNDaGFuZ2VkTGlzdGVuZXIpXG4gICAgICAgICAgICAgICAgLm9uKCdkaXNwbGF5X3VyaScsIHRoaXMuVVJJTGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q2hhaW5Qcm9wcyhjaGFpbnMsIG9wdGlvbmFsQ2hhaW5zLCBkZXNpcmVkQ2hhaW5JZCA9IHRoaXMuZGVmYXVsdENoYWluSWQpIHtcbiAgICAgICAgLy8gUmVvcmRlciBjaGFpbnMgYW5kIG9wdGlvbmFsQ2hhaW5zIGlmIG5lY2Vzc2FyeVxuICAgICAgICBjb25zdCBvcmRlcmVkQ2hhaW5zID0gKDAsIHV0aWxzXzEuZ2V0Q2hhaW5zV2l0aERlZmF1bHQpKGNoYWlucywgZGVzaXJlZENoYWluSWQpO1xuICAgICAgICBjb25zdCBvcmRlcmVkT3B0aW9uYWxDaGFpbnMgPSAoMCwgdXRpbHNfMS5nZXRDaGFpbnNXaXRoRGVmYXVsdCkob3B0aW9uYWxDaGFpbnMsIGRlc2lyZWRDaGFpbklkKTtcbiAgICAgICAgLy8gVmFsaWRhdGUgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAgICAvLyBUeXBlIGRpc2NyaW1pbmF0aW9uIHJlcXVpcmVzIHRoYXQgd2UgdXNlIHRoZXNlIHR5cGVndWFyZCBjaGVja3MgdG8gZ3VhcmFudGVlIGEgdmFsaWQgcmV0dXJuIHR5cGUuXG4gICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc0FycmF5T25lT3JNb3JlKShvcmRlcmVkQ2hhaW5zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhaW5zOiBvcmRlcmVkQ2hhaW5zLCBvcHRpb25hbENoYWluczogb3JkZXJlZE9wdGlvbmFsQ2hhaW5zIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNBcnJheU9uZU9yTW9yZSkob3JkZXJlZE9wdGlvbmFsQ2hhaW5zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhaW5zOiBvcmRlcmVkQ2hhaW5zLCBvcHRpb25hbENoYWluczogb3JkZXJlZE9wdGlvbmFsQ2hhaW5zIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFaXRoZXIgY2hhaW5zIG9yIG9wdGlvbmFsQ2hhaW5zIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgaXRlbS4nKTtcbiAgICB9XG4gICAgaXNvbW9ycGhpY0luaXRpYWxpemUoZGVzaXJlZENoYWluSWQgPSB0aGlzLmRlZmF1bHRDaGFpbklkKSB7XG4gICAgICAgIGlmICh0aGlzLmVhZ2VyQ29ubmVjdGlvbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhZ2VyQ29ubmVjdGlvbjtcbiAgICAgICAgcmV0dXJuICh0aGlzLmVhZ2VyQ29ubmVjdGlvbiA9IHRoaXMuaW5pdGlhbGl6ZVByb3ZpZGVyKGRlc2lyZWRDaGFpbklkKSk7XG4gICAgfVxuICAgIC8qKiB7QGluaGVyaXRkb2MgQ29ubmVjdG9yLmNvbm5lY3RFYWdlcmx5fSAqL1xuICAgIGNvbm5lY3RFYWdlcmx5KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsQWN0aXZhdGlvbiA9IHRoaXMuYWN0aW9ucy5zdGFydEFjdGl2YXRpb24oKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmlzb21vcnBoaWNJbml0aWFsaXplKCk7XG4gICAgICAgICAgICAgICAgLy8gV2FsbGV0Q29ubmVjdCBhdXRvbWF0aWNhbGx5IHBlcnNpc3RzIGFuZCByZXN0b3JlcyBhY3RpdmUgc2Vzc2lvbnNcbiAgICAgICAgICAgICAgICBpZiAoIXByb3ZpZGVyLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgc2Vzc2lvbiBmb3VuZC4gQ29ubmVjdCB5b3VyIHdhbGxldCBmaXJzdC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnVwZGF0ZSh7IGFjY291bnRzOiBwcm92aWRlci5hY2NvdW50cywgY2hhaW5JZDogcHJvdmlkZXIuY2hhaW5JZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIGNhbmNlbEFjdGl2YXRpb24oKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkZXNpcmVkQ2hhaW5JZCAtIFRoZSBkZXNpcmVkIGNoYWluSWQgdG8gY29ubmVjdCB0by5cbiAgICAgKi9cbiAgICBhY3RpdmF0ZShkZXNpcmVkQ2hhaW5JZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuaXNvbW9ycGhpY0luaXRpYWxpemUoZGVzaXJlZENoYWluSWQpO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlc2lyZWRDaGFpbklkIHx8IGRlc2lyZWRDaGFpbklkID09PSBwcm92aWRlci5jaGFpbklkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gV2FsbGV0Q29ubmVjdCBleHBvc2VzIGNvbm5lY3RlZCBhY2NvdW50cywgbm90IGNoYWluczogYGVpcDE1NToke2NoYWluSWR9OiR7YWRkcmVzc31gXG4gICAgICAgICAgICAgICAgY29uc3QgaXNDb25uZWN0ZWRUb0Rlc2lyZWRDaGFpbiA9IHByb3ZpZGVyLnNlc3Npb24ubmFtZXNwYWNlcy5laXAxNTUuYWNjb3VudHMuc29tZSgoYWNjb3VudCkgPT4gYWNjb3VudC5zdGFydHNXaXRoKGBlaXAxNTU6JHtkZXNpcmVkQ2hhaW5JZH06YCkpO1xuICAgICAgICAgICAgICAgIGlmICghaXNDb25uZWN0ZWRUb0Rlc2lyZWRDaGFpbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5vcHRpb25zLm9wdGlvbmFsQ2hhaW5zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoZGVzaXJlZENoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhY3RpdmF0ZSBhbiBvcHRpb25hbCBjaGFpbiAoJHtkZXNpcmVkQ2hhaW5JZH0pLCBhcyB0aGUgd2FsbGV0IGlzIG5vdCBjb25uZWN0ZWQgdG8gaXQuXFxuXFx0WW91IHNob3VsZCBoYW5kbGUgdGhpcyBlcnJvciBpbiBhcHBsaWNhdGlvbiBjb2RlLCBhcyB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBhIHdhbGxldCBpcyBjb25uZWN0ZWQgdG8gYSBjaGFpbiBjb25maWd1cmVkIGluIFwib3B0aW9uYWxDaGFpbnNcIi5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY2hhaW4gKCR7ZGVzaXJlZENoYWluSWR9KS4gTWFrZSBzdXJlIHRvIGluY2x1ZGUgYW55IGNoYWlucyB5b3UgbWlnaHQgY29ubmVjdCB0byBpbiB0aGUgXCJjaGFpbnNcIiBvciBcIm9wdGlvbmFsQ2hhaW5zXCIgcGFyYW1ldGVycyB3aGVuIGluaXRpYWxpemluZyBXYWxsZXRDb25uZWN0LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbeyBjaGFpbklkOiBgMHgke2Rlc2lyZWRDaGFpbklkLnRvU3RyaW5nKDE2KX1gIH1dLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FuY2VsQWN0aXZhdGlvbiA9IHRoaXMuYWN0aW9ucy5zdGFydEFjdGl2YXRpb24oKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgcHJvdmlkZXIuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnVwZGF0ZSh7IGNoYWluSWQ6IHByb3ZpZGVyLmNoYWluSWQsIGFjY291bnRzOiBwcm92aWRlci5hY2NvdW50cyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIGNhbmNlbEFjdGl2YXRpb24oKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiB7QGluaGVyaXRkb2MgQ29ubmVjdG9yLmRlYWN0aXZhdGV9ICovXG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5wcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUxpc3RlbmVyKCdkaXNjb25uZWN0JywgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXIpLnJlbW92ZUxpc3RlbmVyKCdjaGFpbkNoYW5nZWQnLCB0aGlzLmNoYWluQ2hhbmdlZExpc3RlbmVyKS5yZW1vdmVMaXN0ZW5lcignYWNjb3VudHNDaGFuZ2VkJywgdGhpcy5hY2NvdW50c0NoYW5nZWRMaXN0ZW5lcikucmVtb3ZlTGlzdGVuZXIoJ2Rpc3BsYXlfdXJpJywgdGhpcy5VUklMaXN0ZW5lcikuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZWFnZXJDb25uZWN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5XYWxsZXRDb25uZWN0ID0gV2FsbGV0Q29ubmVjdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-react/walletconnect-v2/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@web3-react/walletconnect-v2/dist/utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@web3-react/walletconnect-v2/dist/utils.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getChainsWithDefault = exports.getBestUrlMap = exports.isArrayOneOrMore = void 0;\n/**\n * This is a type guard for ArrayOneOrMore\n */\nfunction isArrayOneOrMore(input = []) {\n    return input.length > 0;\n}\nexports.isArrayOneOrMore = isArrayOneOrMore;\n/**\n * @param rpcMap - Map of chainIds to rpc url(s).\n * @param timeout - Timeout, in milliseconds, after which to consider network calls failed.\n */\nfunction getBestUrlMap(rpcMap, timeout) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return Object.fromEntries(yield Promise.all(Object.entries(rpcMap).map(([chainId, map]) => __awaiter(this, void 0, void 0, function* () { return [chainId, yield getBestUrl(map, timeout)]; }))));\n    });\n}\nexports.getBestUrlMap = getBestUrlMap;\n/**\n * @param urls - An array of URLs to try to connect to.\n * @param timeout - {@link getBestUrlMap}\n */\nfunction getBestUrl(urls, timeout) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // if we only have 1 url, it's the best!\n        if (typeof urls === 'string')\n            return urls;\n        if (urls.length === 1)\n            return urls[0];\n        const [HttpConnection, JsonRpcProvider] = yield Promise.all([\n            Promise.resolve().then(() => __importStar(__webpack_require__(/*! @walletconnect/jsonrpc-http-connection */ \"(ssr)/./node_modules/@walletconnect/jsonrpc-http-connection/dist/index.es.js\"))).then(({ HttpConnection }) => HttpConnection),\n            Promise.resolve().then(() => __importStar(__webpack_require__(/*! @walletconnect/jsonrpc-provider */ \"(ssr)/./node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js\"))).then(({ JsonRpcProvider }) => JsonRpcProvider),\n        ]);\n        // the below returns the first url for which there's been a successful call, prioritized by index\n        return new Promise((resolve) => {\n            let resolved = false;\n            const successes = {};\n            urls.forEach((url, i) => {\n                const http = new JsonRpcProvider(new HttpConnection(url));\n                // create a promise that resolves on a successful call, and rejects on a failed call or after timeout milliseconds\n                const promise = new Promise((resolve, reject) => {\n                    http\n                        .request({ method: 'eth_chainId' })\n                        .then(() => resolve())\n                        .catch(() => reject());\n                    // set a timeout to reject\n                    setTimeout(() => {\n                        reject();\n                    }, timeout);\n                });\n                void promise\n                    .then(() => true)\n                    .catch(() => false)\n                    .then((success) => {\n                    // if we already resolved, return\n                    if (resolved)\n                        return;\n                    // store the result of the call\n                    successes[i] = success;\n                    // if this is the last call and we haven't resolved yet - do so\n                    if (Object.keys(successes).length === urls.length) {\n                        const index = Object.keys(successes).findIndex((j) => successes[Number(j)]);\n                        // no need to set resolved to true, as this is the last promise\n                        return resolve(urls[index === -1 ? 0 : index]);\n                    }\n                    // otherwise, for each prospective index, check if we can resolve\n                    new Array(urls.length).fill(0).forEach((_, prospectiveIndex) => {\n                        // to resolve, we need to:\n                        // a) have successfully made a call\n                        // b) not be waiting on any other higher-index calls\n                        if (successes[prospectiveIndex] &&\n                            new Array(prospectiveIndex).fill(0).every((_, j) => successes[j] === false)) {\n                            resolved = true;\n                            resolve(urls[prospectiveIndex]);\n                        }\n                    });\n                });\n            });\n        });\n    });\n}\n/**\n * @param chains - An array of chain IDs.\n * @param defaultChainId - The chain ID to treat as the default (it will be the first element in the returned array).\n */\nfunction getChainsWithDefault(chains, defaultChainId) {\n    if (!chains || !defaultChainId || chains.length === 0) {\n        return chains;\n    }\n    const idx = chains.indexOf(defaultChainId);\n    if (idx === -1) {\n        throw new Error(`Invalid chainId ${defaultChainId}. Make sure default chain is included in \"chains\" - chains specified in \"optionalChains\" may not be selected as the default, as they may not be supported by the wallet.`);\n    }\n    const ordered = [...chains];\n    ordered.splice(idx, 1);\n    return [defaultChainId, ...ordered];\n}\nexports.getChainsWithDefault = getChainsWithDefault;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3Qvd2FsbGV0Y29ubmVjdC12Mi9kaXN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcscUJBQXFCLEdBQUcsd0JBQXdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osbURBQW1EO0FBQ3JNLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBTyxDQUFDLDRIQUF3QyxZQUFZLGdCQUFnQjtBQUNsSSxzREFBc0QsbUJBQU8sQ0FBQyw4R0FBaUMsWUFBWSxpQkFBaUI7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dhbGxldC1jb25uZWN0aW9ucy8uL25vZGVfbW9kdWxlcy9Ad2ViMy1yZWFjdC93YWxsZXRjb25uZWN0LXYyL2Rpc3QvdXRpbHMuanM/YmUzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldENoYWluc1dpdGhEZWZhdWx0ID0gZXhwb3J0cy5nZXRCZXN0VXJsTWFwID0gZXhwb3J0cy5pc0FycmF5T25lT3JNb3JlID0gdm9pZCAwO1xuLyoqXG4gKiBUaGlzIGlzIGEgdHlwZSBndWFyZCBmb3IgQXJyYXlPbmVPck1vcmVcbiAqL1xuZnVuY3Rpb24gaXNBcnJheU9uZU9yTW9yZShpbnB1dCA9IFtdKSB7XG4gICAgcmV0dXJuIGlucHV0Lmxlbmd0aCA+IDA7XG59XG5leHBvcnRzLmlzQXJyYXlPbmVPck1vcmUgPSBpc0FycmF5T25lT3JNb3JlO1xuLyoqXG4gKiBAcGFyYW0gcnBjTWFwIC0gTWFwIG9mIGNoYWluSWRzIHRvIHJwYyB1cmwocykuXG4gKiBAcGFyYW0gdGltZW91dCAtIFRpbWVvdXQsIGluIG1pbGxpc2Vjb25kcywgYWZ0ZXIgd2hpY2ggdG8gY29uc2lkZXIgbmV0d29yayBjYWxscyBmYWlsZWQuXG4gKi9cbmZ1bmN0aW9uIGdldEJlc3RVcmxNYXAocnBjTWFwLCB0aW1lb3V0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh5aWVsZCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhycGNNYXApLm1hcCgoW2NoYWluSWQsIG1hcF0pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIFtjaGFpbklkLCB5aWVsZCBnZXRCZXN0VXJsKG1hcCwgdGltZW91dCldOyB9KSkpKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0QmVzdFVybE1hcCA9IGdldEJlc3RVcmxNYXA7XG4vKipcbiAqIEBwYXJhbSB1cmxzIC0gQW4gYXJyYXkgb2YgVVJMcyB0byB0cnkgdG8gY29ubmVjdCB0by5cbiAqIEBwYXJhbSB0aW1lb3V0IC0ge0BsaW5rIGdldEJlc3RVcmxNYXB9XG4gKi9cbmZ1bmN0aW9uIGdldEJlc3RVcmwodXJscywgdGltZW91dCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIC8vIGlmIHdlIG9ubHkgaGF2ZSAxIHVybCwgaXQncyB0aGUgYmVzdCFcbiAgICAgICAgaWYgKHR5cGVvZiB1cmxzID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiB1cmxzO1xuICAgICAgICBpZiAodXJscy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gdXJsc1swXTtcbiAgICAgICAgY29uc3QgW0h0dHBDb25uZWN0aW9uLCBKc29uUnBjUHJvdmlkZXJdID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBfX2ltcG9ydFN0YXIocmVxdWlyZSgnQHdhbGxldGNvbm5lY3QvanNvbnJwYy1odHRwLWNvbm5lY3Rpb24nKSkpLnRoZW4oKHsgSHR0cENvbm5lY3Rpb24gfSkgPT4gSHR0cENvbm5lY3Rpb24pLFxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBfX2ltcG9ydFN0YXIocmVxdWlyZSgnQHdhbGxldGNvbm5lY3QvanNvbnJwYy1wcm92aWRlcicpKSkudGhlbigoeyBKc29uUnBjUHJvdmlkZXIgfSkgPT4gSnNvblJwY1Byb3ZpZGVyKSxcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIHRoZSBiZWxvdyByZXR1cm5zIHRoZSBmaXJzdCB1cmwgZm9yIHdoaWNoIHRoZXJlJ3MgYmVlbiBhIHN1Y2Nlc3NmdWwgY2FsbCwgcHJpb3JpdGl6ZWQgYnkgaW5kZXhcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IHt9O1xuICAgICAgICAgICAgdXJscy5mb3JFYWNoKCh1cmwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBodHRwID0gbmV3IEpzb25ScGNQcm92aWRlcihuZXcgSHR0cENvbm5lY3Rpb24odXJsKSk7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uIGEgc3VjY2Vzc2Z1bCBjYWxsLCBhbmQgcmVqZWN0cyBvbiBhIGZhaWxlZCBjYWxsIG9yIGFmdGVyIHRpbWVvdXQgbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaHR0cFxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfY2hhaW5JZCcgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHJlc29sdmUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiByZWplY3QoKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBhIHRpbWVvdXQgdG8gcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZvaWQgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChzdWNjZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFscmVhZHkgcmVzb2x2ZWQsIHJldHVyblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2VzW2ldID0gc3VjY2VzcztcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCBjYWxsIGFuZCB3ZSBoYXZlbid0IHJlc29sdmVkIHlldCAtIGRvIHNvXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzdWNjZXNzZXMpLmxlbmd0aCA9PT0gdXJscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gT2JqZWN0LmtleXMoc3VjY2Vzc2VzKS5maW5kSW5kZXgoKGopID0+IHN1Y2Nlc3Nlc1tOdW1iZXIoaildKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gc2V0IHJlc29sdmVkIHRvIHRydWUsIGFzIHRoaXMgaXMgdGhlIGxhc3QgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodXJsc1tpbmRleCA9PT0gLTEgPyAwIDogaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGZvciBlYWNoIHByb3NwZWN0aXZlIGluZGV4LCBjaGVjayBpZiB3ZSBjYW4gcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAgICBuZXcgQXJyYXkodXJscy5sZW5ndGgpLmZpbGwoMCkuZm9yRWFjaCgoXywgcHJvc3BlY3RpdmVJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gcmVzb2x2ZSwgd2UgbmVlZCB0bzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEpIGhhdmUgc3VjY2Vzc2Z1bGx5IG1hZGUgYSBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiKSBub3QgYmUgd2FpdGluZyBvbiBhbnkgb3RoZXIgaGlnaGVyLWluZGV4IGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc2VzW3Byb3NwZWN0aXZlSW5kZXhdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEFycmF5KHByb3NwZWN0aXZlSW5kZXgpLmZpbGwoMCkuZXZlcnkoKF8sIGopID0+IHN1Y2Nlc3Nlc1tqXSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodXJsc1twcm9zcGVjdGl2ZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0gY2hhaW5zIC0gQW4gYXJyYXkgb2YgY2hhaW4gSURzLlxuICogQHBhcmFtIGRlZmF1bHRDaGFpbklkIC0gVGhlIGNoYWluIElEIHRvIHRyZWF0IGFzIHRoZSBkZWZhdWx0IChpdCB3aWxsIGJlIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSByZXR1cm5lZCBhcnJheSkuXG4gKi9cbmZ1bmN0aW9uIGdldENoYWluc1dpdGhEZWZhdWx0KGNoYWlucywgZGVmYXVsdENoYWluSWQpIHtcbiAgICBpZiAoIWNoYWlucyB8fCAhZGVmYXVsdENoYWluSWQgfHwgY2hhaW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY2hhaW5zO1xuICAgIH1cbiAgICBjb25zdCBpZHggPSBjaGFpbnMuaW5kZXhPZihkZWZhdWx0Q2hhaW5JZCk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYWluSWQgJHtkZWZhdWx0Q2hhaW5JZH0uIE1ha2Ugc3VyZSBkZWZhdWx0IGNoYWluIGlzIGluY2x1ZGVkIGluIFwiY2hhaW5zXCIgLSBjaGFpbnMgc3BlY2lmaWVkIGluIFwib3B0aW9uYWxDaGFpbnNcIiBtYXkgbm90IGJlIHNlbGVjdGVkIGFzIHRoZSBkZWZhdWx0LCBhcyB0aGV5IG1heSBub3QgYmUgc3VwcG9ydGVkIGJ5IHRoZSB3YWxsZXQuYCk7XG4gICAgfVxuICAgIGNvbnN0IG9yZGVyZWQgPSBbLi4uY2hhaW5zXTtcbiAgICBvcmRlcmVkLnNwbGljZShpZHgsIDEpO1xuICAgIHJldHVybiBbZGVmYXVsdENoYWluSWQsIC4uLm9yZGVyZWRdO1xufVxuZXhwb3J0cy5nZXRDaGFpbnNXaXRoRGVmYXVsdCA9IGdldENoYWluc1dpdGhEZWZhdWx0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-react/walletconnect-v2/dist/utils.js\n");

/***/ })

};
;